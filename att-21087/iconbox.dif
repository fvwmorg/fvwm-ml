*** TO-DO.orig	Mon Oct  6 22:07:03 1997
--- TO-DO	Mon Oct  6 22:10:06 1997
***************
*** 138,144 ****
  
    - Mouse button chording?
  
!   - Grid the icon box areas?  Add better overall icon handling options?
      Make an optional global free icon placement grid?
    - IconBoxGravity to control placement within the IconBox
      (left/right/top/bottom)?
--- 138,144 ----
  
    - Mouse button chording?
  
!   - Add better overall icon handling options?
      Make an optional global free icon placement grid?
    - IconBoxGravity to control placement within the IconBox
      (left/right/top/bottom)?
***************
*** 227,234 ****
    - Allow env var to specify an additional read directory ($FVWMRCDIR
      or $FVWMHOME or something similiar)?
  
-   - Allow multiple IconBox's for same style def?
- 
    - Add way to specify max (& min?) desk number, and make desk change
      functions wrap at bounds?
  
--- 227,232 ----
*** fvwm/fvwm.man.orig	Mon Oct  6 21:08:15 1997
--- fvwm/fvwm.man	Mon Oct  6 22:16:27 1997
***************
*** 1501,1506 ****
--- 1501,1507 ----
  
  \fIoptions\fP is a comma separated list containing some or all of the
  keywords BorderWidth, HandleWidth, NoIcon/Icon, MiniIcon, IconBox,
+ IconGrid,
  NoTitle/Title, NoHandles/Handles, WindowListSkip/WindowListHit,
  CirculateSkip/CirculateHit, StaysOnTop/StaysPut, Sticky/Slippery,
  StartIconic/StartNormal, Color, ForeColor, BackColor,
***************
*** 1521,1536 ****
  Icon takes an (optional) unquoted string argument which is the icon
  bitmap or pixmap to use.
  
! IconBox takes four numeric arguments:
  .EX
  IconBox	l t r b
  .EE
  Where l is the left coordinate, t is the top, r is right and b is
  bottom. Negative coordinates indicate distance from the right or
! bottom of the screen.  The iconbox is a region of the screen will fvwm
! will attempt to put icons for this window, as long as they do not
  overlap other icons.
  
  MiniIcon specifies a pixmap to use as the miniature icon for the
  window.  This miniature icon can be drawn in a title-bar button (see
  ButtonStyle), and can be used by various fvwm modules (FvwmWinList,
--- 1522,1565 ----
  Icon takes an (optional) unquoted string argument which is the icon
  bitmap or pixmap to use.
  
! IconBox takes four numeric arguments or an X11 geometry string:
  .EX
  IconBox	l t r b
  .EE
+ or
  Where l is the left coordinate, t is the top, r is right and b is
  bottom. Negative coordinates indicate distance from the right or
! bottom of the screen.
! Perhaps easier to use is an X11 Geometry string:
! .EX
! IconBox	-80x200-1-1
! .EE
! Which would place an 80 by 240 pixel iconbox in the lower right hand
! corner of the screen.
! The iconbox is a region of the screen where fvwm
! attempts to put icons for any matching window, as long as they do not
  overlap other icons.
+ Multiple icon boxes can be defined as overflow areas.  When the first
+ icon box is filled, the second one is filled.  All the icon boxes for
+ one style must be defined in 1 command.  For example:
+ .EX
+ Style "*" IconBox -80x200-1-1, IconBox -160x200-81-1
+ .EE
+ Currently icon boxes are always filled right to left, top to bottom.
  
+ IconGrid takes 2 numeric arguments greater than zero.
+ .EX
+ IconGrid x y
+ .EE
+ Icons are placed in an icon box by stepping thru the icon box using
+ the x and y values for the icon grid, looking for a free space.
+ The default grid is 3 by 3 pixels.
+ An IconGrid definition must follow the IconBox definition that it
+ applies to:
+ .EX
+ Style "*" IconBox -80x240-1-1, IconGrid 90 90
+ .EE
+ 
  MiniIcon specifies a pixmap to use as the miniature icon for the
  window.  This miniature icon can be drawn in a title-bar button (see
  ButtonStyle), and can be used by various fvwm modules (FvwmWinList,
*** fvwm/fvwm.h.orig	Sun Oct  5 16:35:05 1997
--- fvwm/fvwm.h	Sun Oct  5 19:29:49 1997
***************
*** 126,131 ****
--- 126,147 ----
  struct FvwmDecor;		/* definition in screen.h */
  #endif
  
+ /*
+   For 1 style statement, there can be any number of IconBoxes.
+   The name list points at the first one in the chain.
+  */
+ typedef struct icon_boxes_struct {
+   struct icon_boxes_struct *next;       /* next icon_boxes or zero */
+   int IconBox[4];                       /* x/y x/y for iconbox */
+   short IconGrid[2];                    /* x incr, y incr */
+ #if this_was_even_designed
+   /* This only takes 2 bits.  The defaults are right, top. */
+ #define ICONFILLBOT (1<<0)
+ #define ICONFILLLFT (1<<1)
+   unsigned char IconFill;               /* fill top,right,left,bot */
+ #endif
+ } icon_boxes;
+ 
  /* for each window that is on the display, one of these structures
   * is allocated and linked into a list 
   */
***************
*** 212,219 ****
      Pixel TextPixel;
      Pixel BackPixel;
      unsigned long buttons;
!     int IconBox[4];
!     int BoxFillMethod;
  } FvwmWindow;
  
  /***************************************************************************
--- 228,234 ----
      Pixel TextPixel;
      Pixel BackPixel;
      unsigned long buttons;
!     icon_boxes *IconBoxes;              /* zero or more iconboxes */
  } FvwmWindow;
  
  /***************************************************************************
*** fvwm/misc.h.orig	Fri Oct  3 20:25:23 1997
--- fvwm/misc.h	Sun Oct  5 17:03:31 1997
***************
*** 33,40 ****
    int resize_width;
    char *ForeColor;
    char *BackColor;
!   int IconBox[4];
!   int BoxFillMethod;
    unsigned long on_buttons;
    unsigned long off_buttons;
  
--- 33,39 ----
    int resize_width;
    char *ForeColor;
    char *BackColor;
!   icon_boxes *IconBoxes;                /* pointer to iconbox(s) */
    unsigned long on_buttons;
    unsigned long off_buttons;
  
***************
*** 130,147 ****
  extern char NoClass[];
  extern char NoResource[];
  
! extern unsigned long LookInList(name_list *, char *, XClassHint *, 
! 				char **value,
! #ifdef MINI_ICONS
!                                 char **mini_value, 
! #endif
! #ifdef USEDECOR
! 				char **decor,
! #endif
!                                 int *Desk, int *bw, int *nobw,
! 				char **forecolor, char **backcolor, 
!                                 unsigned long * buttons, int *IconBox, 
! 				int *BoxFillMethod);
  extern void       MoveOutline(Window, int,int,int,int);
  extern void       DoResize(int, int, FvwmWindow *);
  extern void       DisplaySize(FvwmWindow *, int, int, Bool);
--- 129,135 ----
  extern char NoClass[];
  extern char NoResource[];
  
! extern void       LookInList(FvwmWindow *, name_list *);
  extern void       MoveOutline(Window, int,int,int,int);
  extern void       DoResize(int, int, FvwmWindow *);
  extern void       DisplaySize(FvwmWindow *, int, int, Bool);
***************
*** 311,329 ****
  void ParseKeyEntry(XEvent *eventp,Window w,FvwmWindow *tmp_win,
  		unsigned long context, char *tline,int* Module);
  void SetOneStyle(char *text,FILE *,char **,int *);
- void AddToList(char *name, char *icon_name,
- #ifdef MINI_ICONS
-                char *miniicon_name,
- #endif
- #ifdef USEDECOR
- 	       char *decor,
- #endif
-                unsigned long off_flags, 
- 	       unsigned long on_flags, int desk,int bw, int nobw, 
- 	       char *forecolor, char *backcolor,
-                unsigned long off_buttons, unsigned long on_buttons,
- 	       int *IconBox, int BoxFillMethod);
- 
  void ParseStyle(char *text,FILE *,char **,int *);
  void assign_string(char *text, FILE *fd, char **arg,int *);
  void SetFlag(char *text, FILE *fd, char **arg,int *);
--- 299,304 ----
*** fvwm/icons.c.orig	Sun Sep 28 20:09:31 1997
--- fvwm/icons.c	Mon Oct  6 20:50:51 1997
***************
*** 351,357 ****
  
  
    
! /***********************************************************************
   *
   *  Procedure:
   *	AutoPlace - Find a home for an icon
--- 351,357 ----
  
  
    
!  /***********************************************************************
   *
   *  Procedure:
   *	AutoPlace - Find a home for an icon
***************
*** 404,499 ****
        t->icon_x_loc = t->wmhints->icon_x;
        t->icon_y_loc = t->wmhints->icon_y;
      }
!   else if(t->IconBox[0] >= 0)
!     {
!       width = t->icon_p_width;
!       height = t->icon_w_height + t->icon_p_height;
!       loc_ok = False;  
!       
!       /* check all boxes in order */
        /* In each IconBox, start at the upper left, travel right, then
         * down */
!       test_y = t->IconBox[1]+base_y;
        
-       temp_h = height;
-       temp_w = width;
        
!       /* OK second try at this.
!        * If the window is taller than the icon box, ignore the icon height
         * when figuring where to put it. Same goes for the width */
        /* This should permit reasonably graceful handling of big icons. */
!       if(width >= (t->IconBox[2] - t->IconBox[0]))
! 	    temp_w = 0;
! 	  if(height >= (t->IconBox[3] - t->IconBox[1]))
! 	    temp_h = 0;
! 	  
! 	  while(((test_y + temp_h) < (t->IconBox[3]+base_y))&&(!loc_ok))
! 	    {
! 	      test_x = t->IconBox[0]+base_x;
! 	      while(((test_x + temp_w) < (t->IconBox[2]+base_x))&&
! 		    (!loc_ok))
! 		{
! 		  real_x = test_x;
! 		  real_y = test_y;
! 		  
! 		  if(test_x + width > (Scr.MyDisplayWidth-2+base_x))
! 		    real_x = Scr.MyDisplayWidth - width -2 + base_x;
! 		  if(test_y + height > (Scr.MyDisplayHeight-2+base_y))
! 		    real_y = Scr.MyDisplayHeight - height -2+base_y;
! 		  if(test_x <base_x)
! 		    real_x = base_x;
! 		  if(test_y < base_y)
! 		    real_y = base_y;
! 		  loc_ok = True;
! 		  test_window = Scr.FvwmRoot.next;
! 		  while((test_window != (FvwmWindow *)0)&&(loc_ok == True))
! 		    {
! 		      if(test_window->Desk == t->Desk)
! 			{
! 			  if((test_window->flags&ICONIFIED)&&
!                              (test_window->icon_w||test_window->icon_pixmap_w)&&
! 			     (test_window != t))
! 			    {
! 			      tw=test_window->icon_p_width;
! 			      th=test_window->icon_p_height+
! 				test_window->icon_w_height;
! 			      tx = test_window->icon_x_loc;
! 			      ty = test_window->icon_y_loc;
! 			  
! 			      if((tx<(real_x+width+3))&&((tx+tw+3) > real_x)&&
! 				 (ty<(real_y+height+3))&&((ty+th + 3)>real_y))
! 				{
! 				  loc_ok = False;
! 				}
! 			    }
! 			}
! 		      test_window = test_window->next;
! 		    }
! 		  test_x +=3;
! 		}
! 	      test_y +=3;
! 	    }
!       if(loc_ok == False)
! 	return;
!       t->icon_x_loc = real_x;
!       t->icon_y_loc = real_y;
        
!       if(t->icon_pixmap_w)
! 	XMoveWindow(dpy,t->icon_pixmap_w,t->icon_x_loc, t->icon_y_loc);
    
-       t->icon_w_width = t->icon_p_width;
-       t->icon_xl_loc = t->icon_x_loc;
- 
-       if (t->icon_w != None)
- 	XMoveResizeWindow(dpy, t->icon_w, t->icon_xl_loc,
- 			  t->icon_y_loc+t->icon_p_height, 
- 			  t->icon_w_width,ICON_HEIGHT);
-       Broadcast(M_ICON_LOCATION,7,t->w,t->frame,
- 		(unsigned long)t,
- 		t->icon_x_loc,t->icon_y_loc,
- 		t->icon_w_width, t->icon_w_height+ t->icon_p_height);
-     }
-   
  }
  
  /***********************************************************************
--- 404,509 ----
        t->icon_x_loc = t->wmhints->icon_x;
        t->icon_y_loc = t->wmhints->icon_y;
      }
!   /* dje 10/05/97 Look thru chain of icon boxes assigned to window. */
!   else {
!     icon_boxes *icon_boxes_ptr;         /* current icon box */
! 
!     /* Hopefully this makes the following more readable. */
! #define ICONBOX_LFT icon_boxes_ptr->IconBox[0]
! #define ICONBOX_TOP icon_boxes_ptr->IconBox[1]
! #define ICONBOX_RGT icon_boxes_ptr->IconBox[2]
! #define ICONBOX_BOT icon_boxes_ptr->IconBox[3]
! 
!     width = t->icon_p_width;          /* unnecessary copy of width */
!     height = t->icon_w_height + t->icon_p_height; /* total height */
!     loc_ok = False;                   /* no slot found yet */
!     
!     /* check all boxes in order */
!     for(icon_boxes_ptr= t->IconBoxes;   /* init */
!         icon_boxes_ptr != NULL; /* until no more boxes */
!         icon_boxes_ptr = icon_boxes_ptr->next) { /* all boxes */
! 
!       if (loc_ok == True) {
!         break;                          /* leave for loop */
!       }
        /* In each IconBox, start at the upper left, travel right, then
         * down */
!       test_y = ICONBOX_TOP+base_y;      /* right top + screen offset */
        
        
!       /* If the window is taller than the icon box, ignore the icon height
         * when figuring where to put it. Same goes for the width */
        /* This should permit reasonably graceful handling of big icons. */
!       temp_w = width;                     /* init width */
!       if(width >= (ICONBOX_RGT - ICONBOX_LFT)) /* if icon too wide */
!         temp_w = 0;                       /* adjust width to fit */
!       temp_h = height;                    /* init height */
!       if(height >= (ICONBOX_BOT - ICONBOX_TOP)) /* if icon too tall */
!         temp_h = 0;                       /* adjust height to fit */
        
!       while(((test_y+temp_h) < (ICONBOX_BOT+base_y))&&(!loc_ok)) { /* room y */
!         test_x = ICONBOX_LFT+base_x;    /* init x */
!         while(((test_x+temp_w) < (ICONBOX_RGT+base_x))
!               && (!loc_ok)) { /* room x */
!           real_x = test_x;
!           real_y = test_y;
!           
!           if(test_x + width > (Scr.MyDisplayWidth-2+base_x))
!             real_x = Scr.MyDisplayWidth - width -2 + base_x;
!           if(test_y + height > (Scr.MyDisplayHeight-2+base_y))
!             real_y = Scr.MyDisplayHeight - height -2+base_y;
!           if(test_x <base_x)
!             real_x = base_x;
!           if(test_y < base_y)
!             real_y = base_y;
!           loc_ok = True;                  /* this may be a good location */
!           test_window = Scr.FvwmRoot.next;
!           while((test_window != (FvwmWindow *)0)
!                 &&(loc_ok == True)) { /* test overlap */
!             if(test_window->Desk == t->Desk) {
!               if((test_window->flags&ICONIFIED)&&
!                  (test_window->icon_w||test_window->icon_pixmap_w)&&
!                  (test_window != t)) {
!                 tw=test_window->icon_p_width;
!                 th=test_window->icon_p_height+
!                   test_window->icon_w_height;
!                 tx = test_window->icon_x_loc;
!                 ty = test_window->icon_y_loc;
!                 
!                 if((tx<(real_x+width+3))&&((tx+tw+3) > real_x)&&
!                    (ty<(real_y+height+3))&&((ty+th + 3)>real_y)) {
!                   loc_ok = False;         /* don't accept this location */
!                 } /* end if icons overlap */
!               } /* end if its an icon */
!             } /* end if same desk */
!             test_window = test_window->next;
!           } /* end while icons that may overlap */
!           test_x +=icon_boxes_ptr->IconGrid[0]; /* Grid x value */
!         } /* end while room x */
!         test_y +=icon_boxes_ptr->IconGrid[1]; /* Grid y value */
!       } /* end while room y */
!     } /* end for all icon boxes, or found space */
!     if(loc_ok == False)               /* If icon never found a home */
!       return;                         /* just leave it */
!     t->icon_x_loc = real_x;
!     t->icon_y_loc = real_y;
!     
!     if(t->icon_pixmap_w)
!       XMoveWindow(dpy,t->icon_pixmap_w,t->icon_x_loc, t->icon_y_loc);
!     
!     t->icon_w_width = t->icon_p_width;
!     t->icon_xl_loc = t->icon_x_loc;
!     
!     if (t->icon_w != None)
!       XMoveResizeWindow(dpy, t->icon_w, t->icon_xl_loc,
!                         t->icon_y_loc+t->icon_p_height, 
!                         t->icon_w_width,ICON_HEIGHT);
!     Broadcast(M_ICON_LOCATION,7,t->w,t->frame,
!               (unsigned long)t,
!               t->icon_x_loc,t->icon_y_loc,
!               t->icon_w_width, t->icon_w_height+ t->icon_p_height);
!   }
    
  }
  
  /***********************************************************************
*** fvwm/style.c.orig	Thu Oct  2 19:09:30 1997
--- fvwm/style.c	Mon Oct  6 20:49:25 1997
***************
*** 1,5 ****
  /****************************************************************************
!  * This module is all original code 
   * by Rob Nation 
   * Copyright 1993, Robert Nation
   *     You may use this code for any purpose, as long as the original
--- 1,14 ----
  /****************************************************************************
! 
!  * Changed 10/06/97 by dje:
!  * Change single IconBox into chain of IconBoxes.
!  * Allow IconBox to be specified using X Geometry string.
!  * Parse optional IconGrid.
!  * Use macros to make parsing more uniform, and easier to read.
!  * Rewrote AddToList without tons of arg passing and merging.
!  * Added a few comments.
!  *
!  * This module was all original code 
   * by Rob Nation 
   * Copyright 1993, Robert Nation
   *     You may use this code for any purpose, as long as the original
***************
*** 26,31 ****
--- 35,86 ----
  #include "screen.h"
  #include "../version.h"
  
+ static void AddToList(name_list *);     /* prototype */
+ 
+ /* A macro for skipping over white space */
+ #define SKIPSPACE \
+   while(isspace(*restofline))restofline++;
+ 
+ /* A macro for checking the command with a caseless compare */
+ #define ITIS(THIS) \
+   mystrncasecmp(restofline,THIS,sizeof(THIS)-1)==0
+ 
+ /* A macro for skipping over the command without counting it's size */
+ #define SKIP(THIS) \
+   restofline += sizeof(THIS)-1
+ 
+ /* A macro for getting a non-quoted operand */
+ #define GETWORD \
+   SKIPSPACE; \
+   tmp = restofline; \
+   len = 0; \
+   while((tmp != NULL)&&(*tmp != 0)&&(*tmp != ',')&& \
+         (*tmp != '\n')&&(!isspace(*tmp))) { \
+     tmp++; \
+     len++; \
+   }
+ 
+ /* A macro for getting a quoted operand */
+ #define GETQUOTEDWORD \
+   is_quoted = 0; \
+   SKIPSPACE; \
+   if (*restofline == '"') { \
+     is_quoted = 1; \
+     ++restofline; \
+   } \
+   tmp = restofline; \
+   len = 0; \
+   while (tmp && *tmp && \
+          ((!is_quoted&&(*tmp != ',')&&(*tmp != '\n')&&(!isspace(*tmp))) \
+           || (is_quoted&&(*tmp != '\n')&&(*tmp != '"')))) \
+     { \
+       tmp++; \
+       len++; \
+     } \
+     if (tmp && (*tmp == '"')) ++tmp;
+ 
+ /* Process a style command.  First built up in a temp area.
+    If valid, added to the list in a malloced area. */
  void ProcessNewStyle(XEvent *eventp,
                       Window w,
                       FvwmWindow *tmp_win,
***************
*** 33,141 ****
                       char *text,
                       int *Module)
  {
!   char *name, *line;
    char *restofline,*tmp;
-   char *icon_name = NULL;
- #ifdef MINI_ICONS
-   char *miniicon_name = NULL;
- #endif
- #ifdef USEDECOR
-   char *decor = NULL;
- #endif
-   char *forecolor = NULL;
-   char *backcolor = NULL;
-   unsigned long off_buttons=0;
-   unsigned long on_buttons=0;
    name_list *nptr;
!   int butt;
!   int BoxFillMethod = 0;
!   int IconBox[4];
    int num,i;
  
!   int len,desknumber = 0,bw=0, nobw = 0;
!   unsigned long off_flags = 0;
!   unsigned long on_flags = 0;
    
!   IconBox[0] = -1;
!   IconBox[1] = -1;
!   IconBox[2] = Scr.MyDisplayWidth;
!   IconBox[3] = Scr.MyDisplayHeight;
! 
!   restofline = GetNextToken(text,&name);
    /* in case there was no argument! */
!   if((name == NULL)||(restofline == NULL))
!     return;
  
!   while(isspace(*restofline)&&(*restofline != 0))restofline++;
    line = restofline;
  
    if(restofline == NULL)return;
    while((*restofline != 0)&&(*restofline != '\n'))
    {
!     while(isspace(*restofline)) restofline++;
      switch (tolower(restofline[0]))
      {
        case 'a':
!         if(mystrncasecmp(restofline,"ACTIVEPLACEMENT",15)==0)
          {
!           restofline +=15;
!           on_flags |= RANDOM_PLACE_FLAG;
          }
          break;
        case 'b':
!         if(mystrncasecmp(restofline,"BACKCOLOR",9)==0)
          {
!           restofline +=9;
!           while(isspace(*restofline))restofline++;
!           tmp = restofline;
!           len = 0;
!           while((tmp != NULL)&&(*tmp != 0)&&(*tmp != ',')&&
!                 (*tmp != '\n')&&(!isspace(*tmp)))
!           {
!             tmp++;
!             len++;
!           }
            if(len > 0)
            {
!             backcolor = safemalloc(len+1);
!             strncpy(backcolor,restofline,len);
!             backcolor[len] = 0;
!             off_flags |= BACK_COLOR_FLAG;
            }
            restofline = tmp;
          }
!         else if (mystrncasecmp(restofline,"BUTTON",6)==0)
          {
!           restofline +=6;
! 	  
            sscanf(restofline,"%d",&butt);
!           while(isspace(*restofline))restofline++;
!           while((!isspace(*restofline))&&(*restofline!= 0)&&
!                 (*restofline != ',')&&(*restofline != '\n'))
!             restofline++;
!           while(isspace(*restofline))restofline++;
! 	  
            if (butt == 0) butt = 10;
            if (butt > 0 && butt <= 10)
!             on_buttons |= (1<<(butt-1));
          }
!         else if(mystrncasecmp(restofline,"BorderWidth",11)==0)
          {
!           restofline +=11;
!           off_flags |= BW_FLAG;
!           sscanf(restofline,"%d",&bw);
!           while(isspace(*restofline))restofline++;
!           while((!isspace(*restofline))&&(*restofline!= 0)&&
!                 (*restofline != ',')&&(*restofline != '\n'))
!             restofline++;
!           while(isspace(*restofline))restofline++;
          }
          break;
        case 'c':
!         if(mystrncasecmp(restofline,"COLOR",5)==0)
          {
!           restofline +=5;
!           while(isspace(*restofline))restofline++;
            tmp = restofline;
            len = 0;
            while((tmp != NULL)&&(*tmp != 0)&&(*tmp != ',')&&
--- 88,170 ----
                       char *text,
                       int *Module)
  {
!   char *line;
    char *restofline,*tmp;
    name_list *nptr;
!   int butt;                             /* work area for button number */
    int num,i;
+   name_list tname;                      /* temp area to build name list */
+   int len = 0;
+   icon_boxes *which = 0;                /* which current boxes to chain to */
+   int is_quoted;                        /* for parsing args with quotes */
  
!   memset(&tname, 0, sizeof(name_list)); /* init temp name_list area */
    
!   restofline = GetNextToken(text,&tname.name); /* parse style name */
    /* in case there was no argument! */
!   if((tname.name == NULL)||(restofline == NULL))/* If no name, or blank cmd */
!     return;                             /* drop it. */
  
! 
!   SKIPSPACE;                            /* skip over white space */
    line = restofline;
  
    if(restofline == NULL)return;
    while((*restofline != 0)&&(*restofline != '\n'))
    {
!     SKIPSPACE;                          /* skip white space */
!     /* It might make more sense to capture the whole word, fix its
!        case, and use strcmp, but there aren't many caseless compares
!        because of this "switch" on the first letter. */
      switch (tolower(restofline[0]))
      {
        case 'a':
!         if(ITIS("ACTIVEPLACEMENT"))
          {
!           SKIP("ACTIVEPLACEMENT");
!           tname.on_flags |= RANDOM_PLACE_FLAG;
          }
          break;
        case 'b':
!         if(ITIS("BACKCOLOR"))
          {
!           SKIP("BACKCOLOR");
!           GETWORD;
            if(len > 0)
            {
!             tname.BackColor = safemalloc(len+1);
!             strncpy(tname.BackColor,restofline,len);
!             tname.BackColor[len] = 0;
!             tname.off_flags |= BACK_COLOR_FLAG;
            }
            restofline = tmp;
          }
!         else if (ITIS("BUTTON"))
          {
!           SKIP("BUTTON");
            sscanf(restofline,"%d",&butt);
!           GETWORD;
!           restofline = tmp;
!           SKIPSPACE;
            if (butt == 0) butt = 10;
            if (butt > 0 && butt <= 10)
!             tname.on_buttons |= (1<<(butt-1));
          }
!         else if(ITIS("BorderWidth"))
          {
!           SKIP("BorderWidth");
!           tname.off_flags |= BW_FLAG;
!           sscanf(restofline,"%d",&tname.border_width);
!           GETWORD;
!           restofline = tmp;
!           SKIPSPACE;
          }
          break;
        case 'c':
!         if(ITIS("COLOR"))
          {
!           SKIP("COLOR");
!           SKIPSPACE;
            tmp = restofline;
            len = 0;
            while((tmp != NULL)&&(*tmp != 0)&&(*tmp != ',')&&
***************
*** 146,155 ****
            }
            if(len > 0)
            {
!             forecolor = safemalloc(len+1);
!             strncpy(forecolor,restofline,len);
!             forecolor[len] = 0;
!             off_flags |= FORE_COLOR_FLAG;
            }
            
            while(isspace(*tmp))tmp++;
--- 175,184 ----
            }
            if(len > 0)
            {
!             tname.ForeColor = safemalloc(len+1);
!             strncpy(tname.ForeColor,restofline,len);
!             tname.ForeColor[len] = 0;
!             tname.off_flags |= FORE_COLOR_FLAG;
            }
            
            while(isspace(*tmp))tmp++;
***************
*** 167,336 ****
              }
              if(len > 0)
              {
!               backcolor = safemalloc(len+1);
!               strncpy(backcolor,restofline,len);
!               backcolor[len] = 0;
!               off_flags |= BACK_COLOR_FLAG;
              }
            }
            restofline = tmp;
          }
!         else if(mystrncasecmp(restofline,"CirculateSkipIcon",17)==0)
          {
!           restofline +=17;
!           off_flags |= CIRCULATE_SKIP_ICON_FLAG;
          }
!         else if(mystrncasecmp(restofline,"CirculateHitIcon",16)==0)
          {
!           restofline +=16;
!           on_flags |= CIRCULATE_SKIP_ICON_FLAG;
          }
!         else if(mystrncasecmp(restofline,"CLICKTOFOCUS",12)==0)
          {
!           restofline +=12;
!           off_flags |= CLICK_FOCUS_FLAG;
!           on_flags |= SLOPPY_FOCUS_FLAG;
          }
!         else if(mystrncasecmp(restofline,"CirculateSkip",13)==0)
          {
!           restofline +=13;
!           off_flags |= CIRCULATESKIP_FLAG;
          }
!         else if(mystrncasecmp(restofline,"CirculateHit",12)==0)
          {
!           restofline +=12;
!           on_flags |= CIRCULATESKIP_FLAG;
          }
          break;
        case 'd':
!         if(mystrncasecmp(restofline,"DecorateTransient",17)==0)
          {
!           restofline +=17;
!           off_flags |= DECORATE_TRANSIENT_FLAG;
          }
!         else if(mystrncasecmp(restofline,"DUMBPLACEMENT",13)==0)
          {
!           restofline +=13;
!           on_flags |= SMART_PLACE_FLAG;
          }
          break;
        case 'e':
          break;
        case 'f':
!         if(mystrncasecmp(restofline,"FORECOLOR",9)==0)
          {
!           restofline +=9;
!           while(isspace(*restofline))restofline++;
!           tmp = restofline;
!           len = 0;
!           while((tmp != NULL)&&(*tmp != 0)&&(*tmp != ',')&&
!                 (*tmp != '\n')&&(!isspace(*tmp)))
!           {
!             tmp++;
!             len++;
!           }
            if(len > 0)
            {
!             forecolor = safemalloc(len+1);
!             strncpy(forecolor,restofline,len);
!             forecolor[len] = 0;
!             off_flags |= FORE_COLOR_FLAG;
            }
            restofline = tmp;
          }
!         else if(mystrncasecmp(restofline,"FVWMBUTTONS",11)==0)
          {
!           restofline +=11;
!           on_flags |= MWM_BUTTON_FLAG;
          }
!         else if(mystrncasecmp(restofline,"FVWMBORDER",10)==0)
          {
!           restofline +=10;
!           on_flags |= MWM_BORDER_FLAG;
          }
!         else if(mystrncasecmp(restofline,"FocusFollowsMouse",17)==0)
          {
!           restofline +=17;
!           on_flags |= CLICK_FOCUS_FLAG;
!           on_flags |= SLOPPY_FOCUS_FLAG;
          }
          break;
        case 'g':
          break;
        case 'h':
!         if(mystrncasecmp(restofline,"HINTOVERRIDE",12)==0)
          {
!           restofline +=12;
!           off_flags |= MWM_OVERRIDE_FLAG;
          }
!         else if(mystrncasecmp(restofline,"HANDLES",7)==0)
          {
!           restofline +=7;
!           on_flags |= NOBORDER_FLAG;
          }
!         else if(mystrncasecmp(restofline,"HandleWidth",11)==0)
          {
!           restofline +=11;
!           off_flags |= NOBW_FLAG;
!           sscanf(restofline,"%d",&nobw);
!           while(isspace(*restofline))restofline++;
!           while((!isspace(*restofline))&&(*restofline!= 0)&&
!                 (*restofline != ',')&&(*restofline != '\n'))
!             restofline++;
!           while(isspace(*restofline))restofline++;
          }
          break;
        case 'i':
!         if(mystrncasecmp(restofline,"IconTitle",9)==0)
          {
!           on_flags |= NOICON_TITLE_FLAG;
!           restofline +=9;
          }
!         else if(mystrncasecmp(restofline,"IconBox",7) == 0)
          {
!           restofline +=7;
!           /* Standard X11 geometry string */
!           num = sscanf(restofline,"%d%d%d%d",&IconBox[0], &IconBox[1],
!                        &IconBox[2],&IconBox[3]);
!           for(i=0;i<num;i++)
!           {
!             while(isspace(*restofline))restofline++;
!             if (*restofline == '-') {   /* If leading minus sign */
!               if (i == 0 || i == 2) {   /* if a width */
!                 IconBox[i] += Scr.MyDisplayWidth;
!               } else {                  /* it must be a height */
!                 IconBox[i] += Scr.MyDisplayHeight;
!               } /* end width/height */
!             } /* end leading minus sign */
!             while((!isspace(*restofline))&&(*restofline!= 0)&&
!                   (*restofline != ',')&&(*restofline != '\n'))
!               restofline++;
!           }
!           if(num !=4)
              fvwm_msg(ERR,"ProcessNewStyle",
!                      "IconBox style requires 4 arguments!");
!         }
!         else if(mystrncasecmp(restofline,"ICON",4)==0)
          {
!           restofline +=4;
!           while(isspace(*restofline))restofline++;
!           tmp = restofline;
!           len = 0;
!           while((tmp != NULL)&&(*tmp != 0)&&(*tmp != ',')&&(*tmp != '\n'))
!           {
!             tmp++;
!             len++;
!           }
            if(len > 0)
            {
!             icon_name = safemalloc(len+1);
!             strncpy(icon_name,restofline,len);
!             icon_name[len] = 0;
!             off_flags |= ICON_FLAG;
!             on_flags |= SUPPRESSICON_FLAG;
            }
            else
!             on_flags |= SUPPRESSICON_FLAG;	    
            restofline = tmp;
          }
          break;
--- 196,434 ----
              }
              if(len > 0)
              {
!               tname.BackColor = safemalloc(len+1);
!               strncpy(tname.BackColor,restofline,len);
!               tname.BackColor[len] = 0;
!               tname.off_flags |= BACK_COLOR_FLAG;
              }
            }
            restofline = tmp;
          }
!         else if(ITIS("CirculateSkipIcon"))
          {
!           SKIP("CirculateSkipIcon");
!           tname.off_flags |= CIRCULATE_SKIP_ICON_FLAG;
          }
!         else if(ITIS("CirculateHitIcon"))
          {
!           SKIP("CirculateHitIcon");
!           tname.on_flags |= CIRCULATE_SKIP_ICON_FLAG;
          }
!         else if(ITIS("CLICKTOFOCUS"))
          {
!           SKIP("CLICKTOFOCUS");
!           tname.off_flags |= CLICK_FOCUS_FLAG;
!           tname.on_flags |= SLOPPY_FOCUS_FLAG;
          }
!         else if(ITIS("CirculateSkip"))
          {
!           SKIP("CirculateSkip");
!           tname.off_flags |= CIRCULATESKIP_FLAG;
          }
!         else if(ITIS("CirculateHit"))
          {
!           SKIP("CirculateHit");
!           tname.on_flags |= CIRCULATESKIP_FLAG;
          }
          break;
        case 'd':
!         if(ITIS("DecorateTransient"))
          {
!           SKIP("DecorateTransient");
!           tname.off_flags |= DECORATE_TRANSIENT_FLAG;
          }
!         else if(ITIS("DUMBPLACEMENT"))
          {
!           SKIP("DUMBPLACEMENT");
!           tname.on_flags |= SMART_PLACE_FLAG;
          }
          break;
        case 'e':
          break;
        case 'f':
!         if(ITIS("FORECOLOR"))
          {
!           SKIP("FORECOLOR");
!           GETWORD;
            if(len > 0)
            {
!             tname.ForeColor = safemalloc(len+1);
!             strncpy(tname.ForeColor,restofline,len);
!             tname.ForeColor[len] = 0;
!             tname.off_flags |= FORE_COLOR_FLAG;
            }
            restofline = tmp;
          }
!         else if(ITIS("FVWMBUTTONS"))
          {
!           SKIP("FVWMBUTTONS");
!           tname.on_flags |= MWM_BUTTON_FLAG;
          }
!         else if(ITIS("FVWMBORDER"))
          {
!           SKIP("FVWMBORDER");
!           tname.on_flags |= MWM_BORDER_FLAG;
          }
!         else if(ITIS("FocusFollowsMouse"))
          {
!           SKIP("FocusFollowsMouse");
!           tname.on_flags |= CLICK_FOCUS_FLAG;
!           tname.on_flags |= SLOPPY_FOCUS_FLAG;
          }
          break;
        case 'g':
          break;
        case 'h':
!         if(ITIS("HINTOVERRIDE"))
          {
!           SKIP("HINTOVERRIDE");
!           tname.off_flags |= MWM_OVERRIDE_FLAG;
          }
!         else if(ITIS("HANDLES"))
          {
!           SKIP("HANDLES");
!           tname.on_flags |= NOBORDER_FLAG;
          }
!         else if(ITIS("HandleWidth"))
          {
!           SKIP("HandleWidth");
!           tname.off_flags |= NOBW_FLAG;
!           sscanf(restofline,"%d",&tname.resize_width);
!           GETWORD;
!           restofline = tmp;
!           SKIPSPACE;
          }
          break;
        case 'i':
!         if(ITIS("IconTitle"))
          {
!           SKIP("IconTitle");
!           tname.on_flags |= NOICON_TITLE_FLAG;
          }
!         else if(ITIS("IconBox"))
          {
!           icon_boxes *IconBoxes = 0;
!           SKIP("IconBox");              /* Skip over word "IconBox" */
!           IconBoxes = (icon_boxes *)safemalloc(sizeof(icon_boxes));
!           memset(IconBoxes, 0, sizeof(icon_boxes)); /* clear it */
!           IconBoxes->IconGrid[0] = 3;   /* init grid x */
!           IconBoxes->IconGrid[1] = 3;   /* init grid y */
!           /* try for 4 numbers x y x y */
!           num = sscanf(restofline,"%d%d%d%d",
!                        &IconBoxes->IconBox[0],
!                        &IconBoxes->IconBox[1],
!                        &IconBoxes->IconBox[2],
!                        &IconBoxes->IconBox[3]);
!           if (num == 4) {               /* if 4 numbers */
!             for(i=0;i<num;i++) {
!               SKIPSPACE;
!               if (*restofline == '-') { /* If leading minus sign */
!                 if (i == 0 || i == 2) { /* if a width */
!                   IconBoxes->IconBox[i] += Scr.MyDisplayWidth;
!                 } else {                  /* it must be a height */
!                   IconBoxes->IconBox[i] += Scr.MyDisplayHeight;
!                 } /* end width/height */
!               } /* end leading minus sign */
!               while((!isspace(*restofline))&&(*restofline!= 0)&&
!                     (*restofline != ',')&&(*restofline != '\n'))
!                 restofline++;
!             }
!             /* Note: here there is no test for valid co-ords, use geom */
!           } else {                      /* Not 4 numeric args dje */
!             char geom_string[25];     /* bigger than =32767x32767+32767+32767 */
!             int geom_flags;
!             GETWORD;                    /* read in 1 word w/o advancing */
!             if(len > 0 && len < 24) {   /* if word found, not too long */
!               strncpy(geom_string,restofline,len); /* copy and null term */
!               geom_string[len] = 0;     /* null terminate it */
!               geom_flags=XParseGeometry(geom_string,
!                                         &IconBoxes->IconBox[0],
!                                         &IconBoxes->IconBox[1], /* x/y */
!                                         &IconBoxes->IconBox[2],
!                                         &IconBoxes->IconBox[3]); /* width/ht */
!               if (IconBoxes->IconBox[2] == 0) { /* zero width ind invalid */
!                 fvwm_msg(ERR,"ProcessNewStyle",
!                 "IconBox requires 4 numbers or geometry! Invalid string <%s>.",
!                          geom_string);
!                 free(IconBoxes);        /* Drop the box */
!                 IconBoxes = 0;          /* forget about it */
!               } else {                  /* got valid iconbox geom */
!                 if (geom_flags&XNegative) {
!                   IconBoxes->IconBox[0] = Scr.MyDisplayWidth /* screen width */
!                     + IconBoxes->IconBox[0] /* neg x coord */
!                     - IconBoxes->IconBox[2] -2; /* width - 2 */
!                 }
!                 if (geom_flags&YNegative) {
!                   IconBoxes->IconBox[1] = Scr.MyDisplayHeight /* scr height */
!                     + IconBoxes->IconBox[1] /* neg y coord */
!                     - IconBoxes->IconBox[3] -2; /* height - 2 */
!                 }
!                 IconBoxes->IconBox[2] +=
!                   IconBoxes->IconBox[0]; /* x + wid = right x */
!                 IconBoxes->IconBox[3] +=
!                   IconBoxes->IconBox[1]; /* y + height = bottom y */
!               } /* end icon geom worked */
!             } else {                    /* no word or too long */
!               fvwm_msg(ERR,"ProcessNewStyle",
!                        "IconBox requires 4 numbers or geometry! Too long (%d).",
!                        len);
!               free(IconBoxes);          /* Drop the box */
!               IconBoxes = 0;            /* forget about it */
!             } /* end word found, not too long */
!             restofline = tmp;           /* got word, move past it */
!           } /* end not 4 args */
!           /* If we created an IconBox, put it in the chain. */
!           if (IconBoxes != 0) {         /* If no error */
!             if (tname.IconBoxes == 0) { /* If first one */
!               tname.IconBoxes = IconBoxes; /* chain to root */
!             } else {                    /* else not first one */
!               which->next = IconBoxes;  /* add to end of chain */
!             } /* end not first one */
!             which = IconBoxes;          /* new current box. save for grid */
!           } /* end no error */
!         } /* end iconbox parameter */
!         else if(ITIS("ICONGRID"))
!         {
!           SKIP("ICONGRID");
!           SKIPSPACE;                    /* skip whitespace after keyword */
!           /* The grid always affects the prior iconbox */
!           if (which == 0) {             /* If no current box */
              fvwm_msg(ERR,"ProcessNewStyle",
!                        "IconGrid must follow an IconBox in same Style command");
!           } else {                      /* have a place to grid */
!             num = sscanf(restofline,"%hd%hd", /* 2 shorts */
!                          &which->IconGrid[0],
!                          &which->IconGrid[1]);
!             if (num != 2 
!                 || which->IconGrid[0] < 1
!                 || which->IconGrid[1] < 1) {
!               fvwm_msg(ERR,"ProcessNewStyle",
!                 "IconGrid needs 2 numbers > 0. Got %d numbers. x=%d y=%d!",
!                        num, (int)which->IconGrid[0], (int)which->IconGrid[1]);
!               which->IconGrid[0] = 3;   /* reset grid x */
!               which->IconGrid[1] = 3;   /* reset grid y */
!             } else {                    /* it worked */
!               GETWORD;                  /* swallow word */
!               restofline = tmp;
!               GETWORD;                  /* swallow word */
!               restofline = tmp;
!             } /* end bad grid */
!           } /* end place to grid */
!         } /* end icongrid */
!         else if(ITIS("ICON"))
          {
!           SKIP("ICON");
!           GETWORD;
            if(len > 0)
            {
!             tname.value = safemalloc(len+1);
!             strncpy(tname.value,restofline,len);
!             tname.value[len] = 0;
!             tname.off_flags |= ICON_FLAG;
!             tname.on_flags |= SUPPRESSICON_FLAG;
            }
            else
!             tname.on_flags |= SUPPRESSICON_FLAG;	    
            restofline = tmp;
          }
          break;
***************
*** 339,477 ****
        case 'k':
          break;
        case 'l':
!         if(mystrncasecmp(restofline,"LENIENCE",8)==0)
          {
!           restofline += 8;
!           off_flags |= LENIENCE_FLAG;
          }
          break;
        case 'm':
!         if(mystrncasecmp(restofline,"MWMBUTTONS",10)==0)
          {
!           restofline +=10;
!           off_flags |= MWM_BUTTON_FLAG;
          }
  #ifdef MINI_ICONS
! 	else if (mystrncasecmp(restofline,"MINIICON", 8) == 0)
  	{
! 	  restofline += 8;
! 	  while (isspace (*restofline)) restofline++;
! 	  tmp = restofline;
! 	  len = 0;
! 	  while((tmp != NULL)&&(*tmp != 0)&&(*tmp != ',')&&(*tmp != '\n'))
!           {
!             tmp++;
!             len++;
!           }
            if(len > 0)
            {
!             miniicon_name = safemalloc(len+1);
!             strncpy(miniicon_name,restofline,len);
!             miniicon_name[len] = 0;
!             off_flags |= MINIICON_FLAG;
            }
            restofline = tmp;
  	}
  #endif
!         else if(mystrncasecmp(restofline,"MWMBORDER",9)==0)
          {
!           restofline +=9;
!           off_flags |= MWM_BORDER_FLAG;
          }
!         else if(mystrncasecmp(restofline,"MWMDECOR",8)==0)
          {
!           restofline +=8;
!           off_flags |= MWM_DECOR_FLAG;
          }
!         else if(mystrncasecmp(restofline,"MWMFUNCTIONS",12)==0)
          {
!           restofline +=12;
!           off_flags |= MWM_FUNCTIONS_FLAG;
          }
!         else if(mystrncasecmp(restofline,"MOUSEFOCUS",10)==0)
          {
!           restofline +=10;
!           on_flags |= CLICK_FOCUS_FLAG;
!           on_flags |= SLOPPY_FOCUS_FLAG;
          }
          break;
        case 'n':
!         if(mystrncasecmp(restofline,"NoIconTitle",11)==0)
          {
!           off_flags |= NOICON_TITLE_FLAG;
!           restofline +=11;
          }
!         else if(mystrncasecmp(restofline,"NOICON",6)==0)
          {
!           restofline +=6;
!           off_flags |= SUPPRESSICON_FLAG;
          }
!         else if(mystrncasecmp(restofline,"NOTITLE",7)==0)
          {
!           restofline +=7;
!           off_flags |= NOTITLE_FLAG;
          }
!         else if(mystrncasecmp(restofline,"NoPPosition",11)==0)
          {
!           restofline +=11;
!           off_flags |= NO_PPOSITION_FLAG;
          }
!         else if(mystrncasecmp(restofline,"NakedTransient",14)==0)
          {
!           restofline +=14;
!           on_flags |= DECORATE_TRANSIENT_FLAG;
          }
!         else if(mystrncasecmp(restofline,"NODECORHINT",11)==0)
          {
!           restofline +=11;
!           on_flags |= MWM_DECOR_FLAG;
          }
!         else if(mystrncasecmp(restofline,"NOFUNCHINT",10)==0)
          {
!           restofline +=10;
!           on_flags |= MWM_FUNCTIONS_FLAG;
          }
!         else if(mystrncasecmp(restofline,"NOOVERRIDE",10)==0)
          {
!           restofline +=10;
!           on_flags |= MWM_OVERRIDE_FLAG;
          }
!         else if(mystrncasecmp(restofline,"NOHANDLES",9)==0)
          {
!           restofline +=9;
!           off_flags |= NOBORDER_FLAG;
          }
!         else if(mystrncasecmp(restofline,"NOLENIENCE",10)==0)
          {
!           restofline += 10;
!           on_flags |= LENIENCE_FLAG;
          }
!         else if (mystrncasecmp(restofline,"NOBUTTON",8)==0)
          {
!           restofline +=8;
  	  
            sscanf(restofline,"%d",&butt);
!           while(isspace(*restofline))restofline++;
!           while((!isspace(*restofline))&&(*restofline!= 0)&&
!                 (*restofline != ',')&&(*restofline != '\n'))
!             restofline++;
!           while(isspace(*restofline))restofline++;
  	  
            if (butt == 0) butt = 10;
            if (butt > 0 && butt <= 10)
!             off_buttons |= (1<<(butt-1));
          }
!         else if(mystrncasecmp(restofline,"NOOLDECOR",9)==0)
          {
!           restofline += 9;
!           on_flags |= OL_DECOR_FLAG;
          }
          break;
        case 'o':
!         if(mystrncasecmp(restofline,"OLDECOR",7)==0)
          {
!           restofline += 7;
!           off_flags |= OL_DECOR_FLAG;
          }
          break;
        case 'p':
--- 437,566 ----
        case 'k':
          break;
        case 'l':
!         if(ITIS("LENIENCE"))
          {
!           SKIP("LENIENCE");
!           tname.off_flags |= LENIENCE_FLAG;
          }
          break;
        case 'm':
!         if(ITIS("MWMBUTTONS"))
          {
!           SKIP("MWMBUTTONS");
!           tname.off_flags |= MWM_BUTTON_FLAG;
          }
  #ifdef MINI_ICONS
! 	else if (ITIS("MINIICON"))
  	{
!           SKIP("MINIICON");
!           GETWORD;
            if(len > 0)
            {
!             tname.mini_value = safemalloc(len+1);
!             strncpy(tname.mini_value,restofline,len);
!             tname.mini_value[len] = 0;
!             tname.off_flags |= MINIICON_FLAG;
            }
            restofline = tmp;
  	}
  #endif
!         else if(ITIS("MWMBORDER"))
          {
!           SKIP("MWMBORDER");
!           tname.off_flags |= MWM_BORDER_FLAG;
          }
!         else if(ITIS("MWMDECOR"))
          {
!           SKIP("MWMDECOR");
!           tname.off_flags |= MWM_DECOR_FLAG;
          }
!         else if(ITIS("MWMFUNCTIONS"))
          {
!           SKIP("MWMFUNCTIONS");
!           tname.off_flags |= MWM_FUNCTIONS_FLAG;
          }
!         else if(ITIS("MOUSEFOCUS"))
          {
!           SKIP("MOUSEFOCUS");
!           tname.on_flags |= CLICK_FOCUS_FLAG;
!           tname.on_flags |= SLOPPY_FOCUS_FLAG;
          }
          break;
        case 'n':
!         if(ITIS("NoIconTitle"))
          {
!           SKIP("NoIconTitle");
!           tname.off_flags |= NOICON_TITLE_FLAG;
          }
!         else if(ITIS("NOICON"))
          {
!           SKIP("NOICON");
!           tname.off_flags |= SUPPRESSICON_FLAG;
          }
!         else if(ITIS("NOTITLE"))
          {
!           SKIP("NOTITLE");
!           tname.off_flags |= NOTITLE_FLAG;
          }
!         else if(ITIS("NoPPosition"))
          {
!           SKIP("NoPPosition");
!           tname.off_flags |= NO_PPOSITION_FLAG;
          }
!         else if(ITIS("NakedTransient"))
          {
!           SKIP("NakedTransient");
!           tname.on_flags |= DECORATE_TRANSIENT_FLAG;
          }
!         else if(ITIS("NODECORHINT"))
          {
!           SKIP("NODECORHINT");
!           tname.on_flags |= MWM_DECOR_FLAG;
          }
!         else if(ITIS("NOFUNCHINT"))
          {
!           SKIP("NOFUNCHINT");
!           tname.on_flags |= MWM_FUNCTIONS_FLAG;
          }
!         else if(ITIS("NOOVERRIDE"))
          {
!           SKIP("NOOVERRIDE");
!           tname.on_flags |= MWM_OVERRIDE_FLAG;
          }
!         else if(ITIS("NOHANDLES"))
          {
!           SKIP("NOHANDLES");
!           tname.off_flags |= NOBORDER_FLAG;
          }
!         else if(ITIS("NOLENIENCE"))
          {
!           SKIP("NOLENIENCE");
!           tname.on_flags |= LENIENCE_FLAG;
          }
!         else if (ITIS("NOBUTTON"))
          {
!           SKIP("NOBUTTON");
  	  
            sscanf(restofline,"%d",&butt);
!           GETWORD;
!           SKIPSPACE;
  	  
            if (butt == 0) butt = 10;
            if (butt > 0 && butt <= 10)
!             tname.off_buttons |= (1<<(butt-1));
!           restofline = tmp;
          }
!         else if(ITIS("NOOLDECOR"))
          {
!           SKIP("NOOLDECOR");
!           tname.on_flags |= OL_DECOR_FLAG;
          }
          break;
        case 'o':
!         if(ITIS("OLDECOR"))
          {
!           SKIP("OLDECOR");
!           tname.off_flags |= OL_DECOR_FLAG;
          }
          break;
        case 'p':
***************
*** 479,698 ****
        case 'q':
          break;
        case 'r':
!         if(mystrncasecmp(restofline,"RANDOMPLACEMENT",15)==0)
          {
!           restofline +=15;
!           off_flags |= RANDOM_PLACE_FLAG;
          }
          break;
        case 's':
!         if(mystrncasecmp(restofline,"SMARTPLACEMENT",14)==0)
          {
!           restofline +=14;
!           off_flags |= SMART_PLACE_FLAG;
          }
!         else if(mystrncasecmp(restofline,"SkipMapping",11)==0)
          {
!           restofline +=11;
!           off_flags |= SHOW_MAPPING;
          }
!         else if(mystrncasecmp(restofline,"ShowMapping",11)==0)
          {
!           restofline +=12;
!           on_flags |= SHOW_MAPPING;
          }
!         else if(mystrncasecmp(restofline,"StickyIcon",10)==0)
          {
!           restofline +=10;
!           off_flags |= STICKY_ICON_FLAG;
          }
!         else if(mystrncasecmp(restofline,"SlipperyIcon",12)==0)
          {
!           restofline +=12;
!           on_flags |= STICKY_ICON_FLAG;
          }
!         else if(mystrncasecmp(restofline,"SLOPPYFOCUS",11)==0)
          {
!           restofline +=11;
!           on_flags |= CLICK_FOCUS_FLAG;
!           off_flags |= SLOPPY_FOCUS_FLAG;
          }
!         else if(mystrncasecmp(restofline,"StartIconic",11)==0)
          {
!           restofline +=11;
!           off_flags |= START_ICONIC_FLAG;
          }
!         else if(mystrncasecmp(restofline,"StartNormal",11)==0)
          {
!           restofline +=11;
!           on_flags |= START_ICONIC_FLAG;
          }
!         else if(mystrncasecmp(restofline,"StaysOnTop",10)==0)
          {
!           restofline +=10;
!           off_flags |= STAYSONTOP_FLAG;	  
          }
!         else if(mystrncasecmp(restofline,"StaysPut",8)==0)
          {
!           restofline +=8;
!           on_flags |= STAYSONTOP_FLAG;	  
          }
!         else if(mystrncasecmp(restofline,"Sticky",6)==0)
          {
!           off_flags |= STICKY_FLAG;	  
!           restofline +=6;
          }
!         else if(mystrncasecmp(restofline,"Slippery",8)==0)
          {
!           on_flags |= STICKY_FLAG;	  
!           restofline +=8;
          }
!         else if(mystrncasecmp(restofline,"STARTSONDESK",12)==0)
          {
!           restofline +=12;
!           off_flags |= STARTSONDESK_FLAG;
!           sscanf(restofline,"%d",&desknumber);
!           while(isspace(*restofline))restofline++;
!           while((!isspace(*restofline))&&(*restofline!= 0)&&
!                 (*restofline != ',')&&(*restofline != '\n'))
!             restofline++;
!           while(isspace(*restofline))restofline++;
          }
!         else if(mystrncasecmp(restofline,"STARTSANYWHERE",14)==0)
          {
!           restofline +=14;
!           on_flags |= STARTSONDESK_FLAG;
          }
          break;
        case 't':
!         if(mystrncasecmp(restofline,"TITLE",5)==0)
          {
!           restofline +=5;
!           on_flags |= NOTITLE_FLAG;
          }
          break;
        case 'u':
!         if(mystrncasecmp(restofline,"UsePPosition",12)==0)
          {
!           restofline +=12;
!           on_flags |= NO_PPOSITION_FLAG;
          }
  #ifdef USEDECOR
!         if(mystrncasecmp(restofline,"UseDecor",8)==0)
          {
!           int is_quoted = 0;
!           restofline += 8;
!           while(isspace(*restofline))restofline++;
!           if (*restofline == '"') {
!               is_quoted = 1;
!               ++restofline;
!           }
!           tmp = restofline;
!           len = 0;
!           while (tmp && *tmp &&
!                  ((!is_quoted&&(*tmp != ',')&&(*tmp != '\n')&&(!isspace(*tmp)))
!                   || (is_quoted&&(*tmp != '\n')&&(*tmp != '"'))))
!           {
!             tmp++;
!             len++;
!           }
!           if (tmp && (*tmp == '"')) ++tmp;
            if (len > 0)
            {
!             decor = safemalloc(len+1);
!             strncpy(decor,restofline,len);
!             decor[len] = 0;
            }
            restofline = tmp;
          }
  #endif
!         else if(mystrncasecmp(restofline,"UseStyle",8)==0)
          {
!           int is_quoted = 0;
!           restofline +=8;
!           while(isspace(*restofline))restofline++;
!           if (*restofline == '"') {
!               is_quoted = 1;
!               ++restofline;
!           }
!           tmp = restofline;
!           len = 0;
!           while (tmp && *tmp &&
!                  ((!is_quoted&&(*tmp != ',')&&(*tmp != '\n')&&(!isspace(*tmp)))
!                   || (is_quoted&&(*tmp != '\n')&&(*tmp != '"'))))
! 	  {
!             tmp++;
! 	    len++;
! 	  }
!           if (tmp && (*tmp == '"')) ++tmp;
!           if (len > 0)
!           {
  	    int hit = 0;            
! 	    /* changed to accumulate multiple Style definitions (veliaa@rpi.edu) */
              for ( nptr = Scr.TheList; nptr; nptr = nptr->next ) {
! 		if (!mystrncasecmp(restofline,nptr->name,len))
! 		{
! 		    if (!hit) {
! 			on_flags      = nptr->on_flags;
! 			off_flags     = nptr->off_flags;
! 			icon_name     = nptr->value;
  #ifdef MINI_ICONS
! 			miniicon_name = nptr->mini_value;
  #endif
  #ifdef USEDECOR
! 			decor	    = nptr->Decor;
  #endif
! 			desknumber    = nptr->Desk;
! 			bw            = nptr->border_width;
! 			nobw          = nptr->resize_width;
! 			forecolor     = nptr->ForeColor;
! 			backcolor     = nptr->BackColor;
! 			BoxFillMethod = nptr->BoxFillMethod;
! 			IconBox[0]    = nptr->IconBox[0];
! 			IconBox[1]    = nptr->IconBox[1];
! 			IconBox[2]    = nptr->IconBox[2];
! 			IconBox[3]    = nptr->IconBox[3];
! 			off_buttons   = nptr->off_buttons;
! 			on_buttons    = nptr->on_buttons;
! 			hit = 1;
! 		    } else {
! 			off_flags     |= nptr->off_flags;
! 			on_flags      &= ~(nptr->on_flags);
! 			off_buttons   |= nptr->off_buttons;
! 			on_buttons    &= ~(nptr->on_buttons);
! 			if(nptr->value) icon_name = nptr->value;
! #ifdef MINI_ICONS
! 			if(nptr->mini_value) miniicon_name = nptr->mini_value;
! #endif
! #ifdef USEDECOR
! 			if(nptr->Decor) decor = nptr->Decor;
! #endif
! 			if(nptr->off_flags & STARTSONDESK_FLAG)
! 			    desknumber = nptr->Desk;
! 			if(nptr->off_flags & BW_FLAG)
! 			    bw = nptr->border_width;
! 			if(nptr->off_flags & NOBW_FLAG)
! 			    nobw = nptr->resize_width;
! 			if(nptr->off_flags & FORE_COLOR_FLAG)
! 			    forecolor = nptr->ForeColor;
! 			if(nptr->off_flags & BACK_COLOR_FLAG)
! 			    backcolor = nptr->BackColor;
! 
! 			if(nptr->BoxFillMethod != 0)
! 			    BoxFillMethod = nptr->BoxFillMethod;
! 			if(nptr->IconBox[0] >= 0)
! 			{
! 			    IconBox[0] = nptr->IconBox[0];
! 			    IconBox[1] = nptr->IconBox[1];
! 			    IconBox[2] = nptr->IconBox[2];
! 			    IconBox[3] = nptr->IconBox[3];
! 			}
! 		    }
! 		}
! 	    }
! 	    restofline = tmp;
! 	    if (!hit)
!             {
                tmp=safemalloc(500);
                strcat(tmp,"UseStyle: ");
                strncat(tmp,restofline-len,len);
--- 568,724 ----
        case 'q':
          break;
        case 'r':
!         if(ITIS("RANDOMPLACEMENT"))
          {
!           SKIP("RANDOMPLACEMENT");
!           tname.off_flags |= RANDOM_PLACE_FLAG;
          }
          break;
        case 's':
!         if(ITIS("SMARTPLACEMENT"))
          {
!           SKIP("SMARTPLACEMENT");
!           tname.off_flags |= SMART_PLACE_FLAG;
          }
!         else if(ITIS("SkipMapping"))
          {
!           SKIP("SkipMapping");
!           tname.off_flags |= SHOW_MAPPING;
          }
!         else if(ITIS("ShowMapping"))
          {
!           SKIP("ShowMapping");
!           tname.on_flags |= SHOW_MAPPING;
          }
!         else if(ITIS("StickyIcon"))
          {
!           SKIP("StickyIcon");
!           tname.off_flags |= STICKY_ICON_FLAG;
          }
!         else if(ITIS("SlipperyIcon"))
          {
!           SKIP("SlipperyIcon");
!           tname.on_flags |= STICKY_ICON_FLAG;
          }
!         else if(ITIS("SLOPPYFOCUS"))
          {
!           SKIP("SLOPPYFOCUS");
!           tname.on_flags |= CLICK_FOCUS_FLAG;
!           tname.off_flags |= SLOPPY_FOCUS_FLAG;
          }
!         else if(ITIS("StartIconic"))
          {
!           SKIP("StartIconic");
!           tname.off_flags |= START_ICONIC_FLAG;
          }
!         else if(ITIS("StartNormal"))
          {
!           SKIP("StartNormal");
!           tname.on_flags |= START_ICONIC_FLAG;
          }
!         else if(ITIS("StaysOnTop"))
          {
!           SKIP("StaysOnTop");
!           tname.off_flags |= STAYSONTOP_FLAG;	  
          }
!         else if(ITIS("StaysPut"))
          {
!           SKIP("StaysPut");
!           tname.on_flags |= STAYSONTOP_FLAG;	  
          }
!         else if(ITIS("Sticky"))
          {
!           tname.off_flags |= STICKY_FLAG;	  
!           SKIP("Sticky");
          }
!         else if(ITIS("Slippery"))
          {
!           tname.on_flags |= STICKY_FLAG;	  
!           SKIP("Slippery");
          }
!         else if(ITIS("STARTSONDESK"))
          {
!           SKIP("STARTSONDESK");
!           tname.off_flags |= STARTSONDESK_FLAG;
!           sscanf(restofline,"%d",&tname.Desk);
!           GETWORD;
!           restofline = tmp;
!           SKIPSPACE;
          }
!         else if(ITIS("STARTSANYWHERE"))
          {
!           SKIP("STARTSANYWHERE");
!           tname.on_flags |= STARTSONDESK_FLAG;
          }
          break;
        case 't':
!         if(ITIS("TITLE"))
          {
!           SKIP("TITLE");
!           tname.on_flags |= NOTITLE_FLAG;
          }
          break;
        case 'u':
!         if(ITIS("UsePPosition"))
          {
!           SKIP("UsePPosition");
!           tname.on_flags |= NO_PPOSITION_FLAG;
          }
  #ifdef USEDECOR
!         if(ITIS("UseDecor"))
          {
!           SKIP("UseDecor");
!           GETQUOTEDWORD;
            if (len > 0)
            {
!             tname.Decor = safemalloc(len+1);
!             strncpy(tname.Decor,restofline,len);
!             tname.Decor[len] = 0;
            }
            restofline = tmp;
          }
  #endif
!         else if(ITIS("UseStyle"))
          {
!           SKIP("UseStyle");
!           GETQUOTEDWORD;
!           if (len > 0) {
  	    int hit = 0;            
! 	    /* changed to accum multiple Style definitions (veliaa@rpi.edu) */
              for ( nptr = Scr.TheList; nptr; nptr = nptr->next ) {
!               if (!mystrncasecmp(restofline,nptr->name,len)) { /* match style */
!                 if (!hit) {             /* first match */
!                   memcpy(&tname, nptr, sizeof(name_list)); /* copy everything */
!                   tname.next = 0;       /* except the next pointer */
!                   hit = 1;              /* set not first match */
!                 } else {                /* subsequent match */
!                   tname.off_flags     |= nptr->off_flags;
!                   tname.on_flags      &= ~(nptr->on_flags);
!                   tname.off_buttons   |= nptr->off_buttons;
!                   tname.on_buttons    &= ~(nptr->on_buttons);
!                   if(nptr->value) tname.value = nptr->value;
  #ifdef MINI_ICONS
!                   if(nptr->mini_value) tname.mini_value = nptr->mini_value;
  #endif
  #ifdef USEDECOR
!                   if(nptr->Decor) tname.Decor = nptr->Decor;
  #endif
!                   if(nptr->off_flags & STARTSONDESK_FLAG)
!                     tname.Desk = nptr->Desk;
!                   if(nptr->off_flags & BW_FLAG)
!                     tname.border_width = nptr->border_width;
!                   if(nptr->off_flags & NOBW_FLAG)
!                     tname.resize_width = nptr->resize_width;
!                   if(nptr->off_flags & FORE_COLOR_FLAG)
!                     tname.ForeColor = nptr->ForeColor;
!                   if(nptr->off_flags & BACK_COLOR_FLAG)
!                     tname.BackColor = nptr->BackColor;
!                   tname.IconBoxes = nptr->IconBoxes; /* use same chain */
!                 } /* end hit/not hit */
!               } /* end found matching style */
! 	    } /* end looking at all styles */
! 	    restofline = tmp;           /* move forward one word */
! 	    if (!hit) {
                tmp=safemalloc(500);
                strcat(tmp,"UseStyle: ");
                strncat(tmp,restofline-len,len);
***************
*** 707,721 ****
        case 'v':
          break;
        case 'w':
!         if(mystrncasecmp(restofline,"WindowListSkip",14)==0)
          {
!           restofline +=14;
!           off_flags |= LISTSKIP_FLAG;
          }
!         else if(mystrncasecmp(restofline,"WindowListHit",13)==0)
          {
!           restofline +=13;
!           on_flags |= LISTSKIP_FLAG;
          }
          break;
        case 'x':
--- 733,747 ----
        case 'v':
          break;
        case 'w':
!         if(ITIS("WindowListSkip"))
          {
!           SKIP("WindowListSkip");
!           tname.off_flags |= LISTSKIP_FLAG;
          }
!         else if(ITIS("WindowListHit"))
          {
!           SKIP("WindowListHit");
!           tname.on_flags |= LISTSKIP_FLAG;
          }
          break;
        case 'x':
***************
*** 728,734 ****
          break;
      }
  
!     while(isspace(*restofline))restofline++;
      if(*restofline == ',')
        restofline++;
      else if((*restofline != 0)&&(*restofline != '\n'))
--- 754,760 ----
          break;
      }
  
!     SKIPSPACE;
      if(*restofline == ',')
        restofline++;
      else if((*restofline != 0)&&(*restofline != '\n'))
***************
*** 737,840 ****
                 "bad style command: %s", restofline);
        return;
      }
!   }
  
    /* capture default icons */
!   if(strcmp(name,"*") == 0)
    {
!     if(off_flags & ICON_FLAG)
!       Scr.DefaultIcon = icon_name;
!     off_flags &= ~ICON_FLAG;
!     icon_name = NULL;
    }
! 
!   AddToList(name,icon_name,
! #ifdef MINI_ICONS
!             miniicon_name,
! #endif
! #ifdef USEDECOR
! 	    decor,
! #endif
!             off_flags,on_flags,desknumber,bw,nobw,
! 	    forecolor,backcolor,off_buttons,on_buttons,IconBox,BoxFillMethod);
  }
  
  
! void AddToList(char *name,
!                char *icon_name,
! #ifdef MINI_ICONS
!                char *miniicon_name,
! #endif
! #ifdef USEDECOR
! 	       char *decor,
! #endif
!                unsigned long off_flags, 
! 	       unsigned long on_flags,
!                int desk,
!                int bw,
!                int nobw,
! 	       char *forecolor,
!                char *backcolor,
!                unsigned long off_buttons,
!                unsigned long on_buttons,
! 	       int *IconBox,
!                int BoxFillMethod)
  {
    name_list *nptr,*lastptr = NULL;
  
!   if((name == NULL)||((off_flags == 0)&&(on_flags == 0)&&(on_buttons == 0)&&
!  		      (off_buttons == 0)&&(IconBox[0] < 0)
! #ifdef MINI_ICONS
! 		      &&(miniicon_name == NULL)
! #endif
! #ifdef USEDECOR
! 		      &&(decor == NULL)
! #endif
!       ))
!   {
!     if(name)
!       free(name);
!     if(icon_name)
!       free(icon_name);
!     return;
!   }
  
    /* used to merge duplicate entries, but that is no longer
     * appropriate since conficting styles are possible, and the
     * last match should win! */
!   for (nptr = Scr.TheList; nptr != NULL; nptr = nptr->next)
!   {
!     lastptr=nptr;
    }
  
!   nptr = (name_list *)safemalloc(sizeof(name_list));
!   nptr->next = NULL;
!   nptr->name = name;
!   nptr->on_flags = on_flags;
!   nptr->off_flags = off_flags;
!   nptr->value = icon_name;
! #ifdef MINI_ICONS
!   nptr->mini_value = miniicon_name;
! #endif
! #ifdef USEDECOR
!   nptr->Decor = decor;
! #endif
!   nptr->Desk = desk;
!   nptr->border_width = bw;
!   nptr->resize_width = nobw;
!   nptr->ForeColor = forecolor;
!   nptr->BackColor = backcolor;
!   nptr->BoxFillMethod = BoxFillMethod;
!   nptr->IconBox[0] = IconBox[0];
!   nptr->IconBox[1] = IconBox[1];
!   nptr->IconBox[2] = IconBox[2];
!   nptr->IconBox[3] = IconBox[3];
!   nptr->off_buttons = off_buttons;
!   nptr->on_buttons = on_buttons;
! 
!   if(lastptr != NULL)
!     lastptr->next = nptr;
!   else
!     Scr.TheList = nptr;
! }
  
--- 763,804 ----
                 "bad style command: %s", restofline);
        return;
      }
!   } /* end while still stuff on command */
  
    /* capture default icons */
!   if(strcmp(tname.name,"*") == 0)
    {
!     if(tname.off_flags & ICON_FLAG)
!       Scr.DefaultIcon = tname.value;
!     tname.off_flags &= ~ICON_FLAG;
!     tname.value = NULL;
    }
!   AddToList(&tname);                /* add temp name list to list */
  }
  
  
! static void AddToList(name_list *tname)
  {
    name_list *nptr,*lastptr = NULL;
  
!   /* This used to contain logic that returned if the style didn't contain
!      anything.  I don't see why we should bother. dje. */
  
    /* used to merge duplicate entries, but that is no longer
     * appropriate since conficting styles are possible, and the
     * last match should win! */
! 
!   /* seems like a pretty inefficient way to keep track of the end
!      of the list, but how long can the style list be? dje */
!   for (nptr = Scr.TheList; nptr != NULL; nptr = nptr->next) {
!     lastptr=nptr;                       /* find end of style list */
    }
  
!   nptr = (name_list *)safemalloc(sizeof(name_list)); /* malloc area */
!   memcpy(nptr, tname, sizeof(name_list)); /* copy term area into list */
!   if(lastptr != NULL)                   /* If not first entry in list */
!     lastptr->next = nptr;               /* chain this entry to the list */
!   else                                  /* else first entry in list */
!     Scr.TheList = nptr;                 /* set the list root pointer. */
! } /* end function */
  
*** fvwm/add_window.c.orig	Sat Oct  4 22:38:38 1997
--- fvwm/add_window.c	Mon Oct  6 20:39:47 1997
***************
*** 70,75 ****
--- 70,77 ----
  extern char *PixmapPath;
  #endif
  
+ static void merge_styles(name_list *, name_list *); /* prototype */
+ 
  /***********************************************************************
   *
   *  Procedure:
***************
*** 92,111 ****
    unsigned long valuemask_save = 0;
  #endif
    XSetWindowAttributes attributes;	/* attributes for create windows */
    int i,width,height;
    int a,b;
-   char *value;
- #ifdef MINI_ICONS
-   char *mini_value;
- #endif
- #ifdef USEDECOR
-   char *decor = NULL;
- #endif
-   unsigned long tflag;
-   int Desk, border_width, resize_width;
    extern Bool NeedToResizeToo;
    extern FvwmWindow *colormap_win;
-   char *forecolor = NULL, *backcolor = NULL;
    int client_argc;
    char **client_argv = NULL, *str_type;
    Bool status;
--- 94,104 ----
    unsigned long valuemask_save = 0;
  #endif
    XSetWindowAttributes attributes;	/* attributes for create windows */
+   name_list styles;                     /* area for merged styles */
    int i,width,height;
    int a,b;
    extern Bool NeedToResizeToo;
    extern FvwmWindow *colormap_win;
    int client_argc;
    char **client_argv = NULL, *str_type;
    Bool status;
***************
*** 195,219 ****
    tmp_win->flags |= BORDER;
    tmp_win->flags |= TITLE;
  
!   tflag = LookInList(Scr.TheList,tmp_win->name,&tmp_win->class, &value,
! #ifdef MINI_ICONS
!                      &mini_value,
! #endif
! #ifdef USEDECOR
! 		     &decor,
! #endif
!                      &Desk,
! 		     &border_width, &resize_width,
!                      &forecolor,&backcolor,&tmp_win->buttons, 
! 		     tmp_win->IconBox,&(tmp_win->BoxFillMethod));
  
  #ifdef USEDECOR
    /* search for a UseDecor tag in the Style */
    tmp_win->fl = NULL;
!   if (decor != NULL) {
        FvwmDecor *fl = &Scr.DefaultDecor;
        for (; fl; fl = fl->next)
! 	  if (mystrcasecmp(decor,fl->tag)==0) {
  	      tmp_win->fl = fl;
  	      break;
  	  }
--- 188,204 ----
    tmp_win->flags |= BORDER;
    tmp_win->flags |= TITLE;
  
!   LookInList(tmp_win, &styles);         /* get merged styles */
  
+   tmp_win->IconBoxes = styles.IconBoxes; /* copy iconboxes ptr (if any) */
+   tmp_win->buttons = styles.on_buttons; /* on and off buttons combined. */
  #ifdef USEDECOR
    /* search for a UseDecor tag in the Style */
    tmp_win->fl = NULL;
!   if (styles.Decor != NULL) {
        FvwmDecor *fl = &Scr.DefaultDecor;
        for (; fl; fl = fl->next)
! 	  if (mystrcasecmp(styles.Decor,fl->tag)==0) {
  	      tmp_win->fl = fl;
  	      break;
  	  }
***************
*** 227,240 ****
    GetMwmHints(tmp_win);
    GetOlHints(tmp_win);
  
!   SelectDecor(tmp_win,tflag,border_width,resize_width); 
  
!   tmp_win->flags |= tflag & ALL_COMMON_FLAGS;
    /* find a suitable icon pixmap */
!   if(tflag & ICON_FLAG)
      {
        /* an icon was specified */
!       tmp_win->icon_bitmap_file = value;
      }
    else if((tmp_win->wmhints)
  	  &&(tmp_win->wmhints->flags & (IconWindowHint|IconPixmapHint)))
--- 212,225 ----
    GetMwmHints(tmp_win);
    GetOlHints(tmp_win);
  
!   SelectDecor(tmp_win,styles.on_flags,styles.border_width,styles.resize_width); 
  
!   tmp_win->flags |= styles.on_flags & ALL_COMMON_FLAGS;
    /* find a suitable icon pixmap */
!   if(styles.on_flags & ICON_FLAG)
      {
        /* an icon was specified */
!       tmp_win->icon_bitmap_file = styles.value;
      }
    else if((tmp_win->wmhints)
  	  &&(tmp_win->wmhints->flags & (IconWindowHint|IconPixmapHint)))
***************
*** 249,256 ****
      }
  
  #ifdef MINI_ICONS
!   if (tflag & MINIICON_FLAG) {
!     tmp_win->mini_pixmap_file = mini_value;
    }
    else {
      tmp_win->mini_pixmap_file = NULL;
--- 234,241 ----
      }
  
  #ifdef MINI_ICONS
!   if (styles.on_flags & MINIICON_FLAG) {
!     tmp_win->mini_pixmap_file = styles.mini_value;
    }
    else {
      tmp_win->mini_pixmap_file = NULL;
***************
*** 269,284 ****
    /* Find out if the client requested a specific desk on the command line. */
    if (XGetCommand (dpy, tmp_win->w, &client_argv, &client_argc)) {
        XrmParseCommand (&db, table, 4, "fvwm", &client_argc, client_argv);
!       status = XrmGetResource (db, "fvwm.desk", "Fvwm.Desk", &str_type, &rm_value);
        if ((status == True) && (rm_value.size != 0)) {
!           Desk = atoi(rm_value.addr);
! 	  tflag |= STARTSONDESK_FLAG;
        }
        XrmDestroyDatabase (db);
        db = NULL;
    }
  
!   if(!PlaceWindow(tmp_win, tflag, Desk))
      return NULL;
  
    /*
--- 254,270 ----
    /* Find out if the client requested a specific desk on the command line. */
    if (XGetCommand (dpy, tmp_win->w, &client_argv, &client_argc)) {
        XrmParseCommand (&db, table, 4, "fvwm", &client_argc, client_argv);
!       status = XrmGetResource (db, "fvwm.desk", "Fvwm.Desk",
!                                &str_type, &rm_value);
        if ((status == True) && (rm_value.size != 0)) {
!           styles.Desk = atoi(rm_value.addr);
! 	  styles.on_flags |= STARTSONDESK_FLAG;
        }
        XrmDestroyDatabase (db);
        db = NULL;
    }
  
!   if(!PlaceWindow(tmp_win, styles.on_flags, styles.Desk))
      return NULL;
  
    /*
***************
*** 314,344 ****
    tmp_win->ShadowPixel = Scr.MenuRelief.back;
    tmp_win->BackPixel = Scr.MenuColors.back;
  
!   if(forecolor != NULL)
!     {
!       XColor color;
  
-       if((XParseColor (dpy, Scr.FvwmRoot.attr.colormap, forecolor, &color))
- 	 &&(XAllocColor (dpy, Scr.FvwmRoot.attr.colormap, &color)))
- 	{
- 	  tmp_win->TextPixel = color.pixel; 
- 	}
-     }
-   if(backcolor != NULL)
-     {
-       XColor color;
  
-       if((XParseColor (dpy, Scr.FvwmRoot.attr.colormap,backcolor, &color))
- 	 &&(XAllocColor (dpy, Scr.FvwmRoot.attr.colormap, &color)))
- 
- 	{
- 	  tmp_win->BackPixel = color.pixel; 
- 	}
-       tmp_win->ShadowPixel = GetShadow(tmp_win->BackPixel);
-       tmp_win->ReliefPixel = GetHilite(tmp_win->BackPixel);
-     }
- 
- 
    /* add the window into the fvwm list */
    tmp_win->next = Scr.FvwmRoot.next;
    if (Scr.FvwmRoot.next != NULL)
--- 300,328 ----
    tmp_win->ShadowPixel = Scr.MenuRelief.back;
    tmp_win->BackPixel = Scr.MenuColors.back;
  
!   if(styles.ForeColor != NULL) {
!     XColor color;
!     
!     if((XParseColor (dpy, Scr.FvwmRoot.attr.colormap, styles.ForeColor, &color))
!        &&(XAllocColor (dpy, Scr.FvwmRoot.attr.colormap, &color)))
!       {
!         tmp_win->TextPixel = color.pixel; 
!       }
!   }
!   if(styles.BackColor != NULL) {
!     XColor color;
!     
!     if((XParseColor (dpy, Scr.FvwmRoot.attr.colormap,styles.BackColor, &color))
!        &&(XAllocColor (dpy, Scr.FvwmRoot.attr.colormap, &color)))
!       
!       {
!         tmp_win->BackPixel = color.pixel; 
!       }
!     tmp_win->ShadowPixel = GetShadow(tmp_win->BackPixel);
!     tmp_win->ReliefPixel = GetHilite(tmp_win->BackPixel);
!   }
  
  
    /* add the window into the fvwm list */
    tmp_win->next = Scr.FvwmRoot.next;
    if (Scr.FvwmRoot.next != NULL)
***************
*** 499,538 ****
  	  else
  	    tmp_win->left_w[i] = None;
  
! 	  if((i<Scr.nr_right_buttons)&&(tmp_win->right_w[i] >0))
! 	    {
  #if defined(PIXMAP_BUTTONS) && defined(BORDERSTYLE)
! 	      if (TexturePixmap
! 		  && GetDecor(tmp_win,right_buttons[i].flags) & UseBorderStyle) {
! 		  TexturePixmapSave = attributes.background_pixmap;
! 		  attributes.background_pixmap = TexturePixmap;
! 		  valuemask_save = valuemask;
! 		  valuemask = (valuemask & ~CWBackPixel) | CWBackPixmap;
! 	      }
  #endif
! 	      tmp_win->right_w[i] =
! 		XCreateWindow (dpy, tmp_win->frame, 
! 			       tmp_win->title_width-
! 			       tmp_win->title_height*(i+1),
! 			       0, tmp_win->title_height,
! 			       tmp_win->title_height, 
! 			       0, CopyFromParent, InputOutput,
! 			       CopyFromParent,
! 			       valuemask,
! 			       &attributes);
  #if defined(PIXMAP_BUTTONS) && defined(BORDERSTYLE)
! 	      if (TexturePixmap
! 		  && GetDecor(tmp_win,right_buttons[i].flags) & UseBorderStyle) {
! 		  attributes.background_pixmap = TexturePixmapSave;
! 		  valuemask = valuemask_save;
! 	      }
  #endif
! 	    }
  	  else
  	    tmp_win->right_w[i] = None;
  	}
      }
! 
    if(tmp_win->flags & BORDER)
      {
  #if defined(PIXMAP_BUTTONS) && defined(BORDERSTYLE)
--- 483,521 ----
  	  else
  	    tmp_win->left_w[i] = None;
  
! 	  if((i<Scr.nr_right_buttons)&&(tmp_win->right_w[i] >0)) {
  #if defined(PIXMAP_BUTTONS) && defined(BORDERSTYLE)
!             if (TexturePixmap
!                 && GetDecor(tmp_win,right_buttons[i].flags) & UseBorderStyle) {
!               TexturePixmapSave = attributes.background_pixmap;
!               attributes.background_pixmap = TexturePixmap;
!               valuemask_save = valuemask;
!               valuemask = (valuemask & ~CWBackPixel) | CWBackPixmap;
!             }
  #endif
!             tmp_win->right_w[i] =
!               XCreateWindow (dpy, tmp_win->frame, 
!                              tmp_win->title_width-
!                              tmp_win->title_height*(i+1),
!                              0, tmp_win->title_height,
!                              tmp_win->title_height, 
!                              0, CopyFromParent, InputOutput,
!                              CopyFromParent,
!                              valuemask,
!                              &attributes);
  #if defined(PIXMAP_BUTTONS) && defined(BORDERSTYLE)
!             if (TexturePixmap
!                 && GetDecor(tmp_win,right_buttons[i].flags) & UseBorderStyle) {
!               attributes.background_pixmap = TexturePixmapSave;
!               valuemask = valuemask_save;
!             }
  #endif
!           }
  	  else
  	    tmp_win->right_w[i] = None;
  	}
      }
!   
    if(tmp_win->flags & BORDER)
      {
  #if defined(PIXMAP_BUTTONS) && defined(BORDERSTYLE)
***************
*** 958,1121 ****
   *	LookInList - look through a list for a window name, or class
   *
   *  Returned Value:
!  *	the ptr field of the list structure or NULL if the name 
!  *	or class was not found in the list
   *
   *  Inputs:
!  *	list	- a pointer to the head of a list
!  *	name	- a pointer to the name to look for
!  *	class	- a pointer to the class to look for
   *
   ***********************************************************************/
! unsigned long LookInList(name_list *list, char *name, XClassHint *class, 
! 			 char **value,
! #ifdef MINI_ICONS
!                          char **mini_value, 
! #endif
! #ifdef USEDECOR
! 			 char **decor,
! #endif
!                          int *Desk, int *border_width,
! 			 int *resize_width, char **forecolor, char **backcolor,
!                          unsigned long * buttons, int *IconBox,
!                          int *BoxFillMethod)
  {
    name_list *nptr;
-   unsigned long retval = 0;
  
!   *value = NULL;
! #ifdef MINI_ICONS
!   *mini_value = NULL;
! #endif
! #ifdef USEDECOR
!   *decor = NULL;
! #endif
!   *forecolor = NULL;
!   *backcolor = NULL;
!   *Desk = 0;
!   *buttons = 0;
!   *BoxFillMethod = 0;
!   *border_width = 0;
!   *resize_width = 0;
!   IconBox[0] = -1;
!   IconBox[1] = -1;
!   IconBox[2] = Scr.MyDisplayWidth;
!   IconBox[3] = Scr.MyDisplayHeight;
  
!   /* look for the name first */
!   for (nptr = list; nptr != NULL; nptr = nptr->next)
!     {
!       if (class)
! 	{
! 	  /* first look for the res_class  (lowest priority) */
! 	  if (matchWildcards(nptr->name,class->res_class) == TRUE)
! 	    {
! 	      if(nptr->value != NULL)*value = nptr->value;
! #ifdef MINI_ICONS
!               if(nptr->mini_value != NULL) *mini_value = nptr->mini_value;
! #endif
! #ifdef USEDECOR
! 	      if (nptr->Decor != NULL) *decor = nptr->Decor;
! #endif
! 	      if(nptr->off_flags & STARTSONDESK_FLAG)
! 		*Desk = nptr->Desk;
! 	      if(nptr->off_flags & BW_FLAG)
! 		*border_width = nptr->border_width;
! 	      if(nptr->off_flags & FORE_COLOR_FLAG)
! 		*forecolor = nptr->ForeColor;
! 	      if(nptr->off_flags & BACK_COLOR_FLAG)
! 		*backcolor = nptr->BackColor;
! 	      if(nptr->off_flags & NOBW_FLAG)
! 		*resize_width = nptr->resize_width;
! 	      retval |= nptr->off_flags;
! 	      retval &= ~(nptr->on_flags);
!               *buttons |= nptr->off_buttons;
!               *buttons &= ~(nptr->on_buttons);
! 	      if(nptr->BoxFillMethod != 0)
! 		*BoxFillMethod = nptr->BoxFillMethod;
! 	      if(nptr->IconBox[0] >= 0)
! 		{
! 		  IconBox[0] = nptr->IconBox[0];
! 		  IconBox[1] = nptr->IconBox[1];
! 		  IconBox[2] = nptr->IconBox[2];
! 		  IconBox[3] = nptr->IconBox[3];
! 		}
! 	    }
  
! 	  /* look for the res_name next */
! 	  if (matchWildcards(nptr->name,class->res_name) == TRUE)
! 	    {
! 	      if(nptr->value != NULL)*value = nptr->value;
  #ifdef MINI_ICONS
!               if(nptr->mini_value != NULL) *mini_value = nptr->mini_value;
  #endif
  #ifdef USEDECOR
! 	      if (nptr->Decor != NULL) *decor = nptr->Decor;
  #endif
! 	      if(nptr->off_flags & STARTSONDESK_FLAG)
! 		*Desk = nptr->Desk;
! 	      if(nptr->off_flags & FORE_COLOR_FLAG)
! 		*forecolor = nptr->ForeColor;
! 	      if(nptr->off_flags & BACK_COLOR_FLAG)
! 		*backcolor = nptr->BackColor;
! 	      if(nptr->off_flags & BW_FLAG)
! 		*border_width = nptr->border_width;
! 	      if(nptr->off_flags & NOBW_FLAG)
! 		*resize_width = nptr->resize_width;
! 	      retval |= nptr->off_flags;
! 	      retval &= ~(nptr->on_flags);
!               *buttons |= nptr->off_buttons;
!               *buttons &= ~(nptr->on_buttons);
! 	      if(nptr->BoxFillMethod != 0)
! 		*BoxFillMethod = nptr->BoxFillMethod;
! 	      if(nptr->IconBox[0] >= 0)
! 		{
! 		  IconBox[0] = nptr->IconBox[0];
! 		  IconBox[1] = nptr->IconBox[1];
! 		  IconBox[2] = nptr->IconBox[2];
! 		  IconBox[3] = nptr->IconBox[3];
! 		}
! 	    }
! 	}
!       /* finally, look for name matches */
!       if (matchWildcards(nptr->name,name) == TRUE)
! 	{
! 	  if(nptr->value != NULL)*value = nptr->value;
! #ifdef MINI_ICONS
!           if(nptr->mini_value != NULL) *mini_value = nptr->mini_value;
! #endif
! #ifdef USEDECOR
! 	  if (nptr->Decor != NULL) *decor = nptr->Decor;
! #endif
! 	  if(nptr->off_flags & STARTSONDESK_FLAG)	   
! 	    *Desk = nptr->Desk;
! 	  if(nptr->off_flags & FORE_COLOR_FLAG)
! 	    *forecolor = nptr->ForeColor;
! 	  if(nptr->off_flags & BACK_COLOR_FLAG)
! 	    *backcolor = nptr->BackColor;
! 	  if(nptr->off_flags & BW_FLAG)
! 	    *border_width = nptr->border_width;
! 	  if(nptr->off_flags & NOBW_FLAG)
! 	    *resize_width = nptr->resize_width;
! 	  retval |= nptr->off_flags;
! 	  retval &= ~(nptr->on_flags);
!           *buttons |= nptr->off_buttons;
!           *buttons &= ~(nptr->on_buttons);
! 	  if(nptr->BoxFillMethod != 0)
! 	    *BoxFillMethod = nptr->BoxFillMethod;
! 	  if(nptr->IconBox[0] >= 0)
! 	    {
! 	      IconBox[0] = nptr->IconBox[0];
! 	      IconBox[1] = nptr->IconBox[1];
! 	      IconBox[2] = nptr->IconBox[2];
! 	      IconBox[3] = nptr->IconBox[3];
! 	    }
! 	}
!     }
!   return retval;
  }
- 
- 
- 
- 
- 
--- 941,1023 ----
   *	LookInList - look through a list for a window name, or class
   *
   *  Returned Value:
!  *	merged matching styles in callers name_list.
   *
   *  Inputs:
!  *	tmp_win - FvwWindow structure to match against
!  *	styles - callers return area
   *
+  *  Changes:
+  *      dje 10/06/97 test for NULL class removed, can't happen.
+  *      use merge subroutine instead of coding merges 3 times.
+  *      Use structure to return values, not many, many args
+  *      and return value.
+  *      Point at iconboxes chain, not single iconboxes elements.
+  *
   ***********************************************************************/
! void LookInList(  FvwmWindow *tmp_win, name_list *styles)
  {
    name_list *nptr;
  
!   memset(styles, 0, sizeof(name_list)); /* clear callers return area */
!   /* look thru all styles in order defined. */
!   for (nptr = Scr.TheList; nptr != NULL; nptr = nptr->next) {
!     /* If name/res_class/res_name match, merge */
!     if (matchWildcards(nptr->name,tmp_win->class.res_class) == TRUE) {
!       merge_styles(styles, nptr);
!     } else if (matchWildcards(nptr->name,tmp_win->class.res_name) == TRUE) {
!       merge_styles(styles, nptr);
!     } else if (matchWildcards(nptr->name,tmp_win->name) == TRUE) {
!       merge_styles(styles, nptr);
!     }
!   }
!   return;
! }
  
! /***********************************************************************
!  *
!  *  Procedure:
!  * merge_styles - For a matching style, merge name_list to name_list
!  *
!  *  Returned Value:
!  *	merged matching styles in callers name_list.
!  *
!  *  Inputs:
!  *	styles - callers return area
!  *      nptr - matching name_list
!  *
!  *  Note:
!  *      The only trick here is that on and off flags/buttons are
!  *      combined into the on flag/button.
!  *
!  ***********************************************************************/
  
! static void merge_styles(name_list *styles, name_list *nptr) {
!   if(nptr->value != NULL) styles->value = nptr->value;
  #ifdef MINI_ICONS
!   if(nptr->mini_value != NULL) styles->mini_value = nptr->mini_value;
  #endif
  #ifdef USEDECOR
!   if (nptr->Decor != NULL) styles->Decor = nptr->Decor;
  #endif
!   if(nptr->off_flags & STARTSONDESK_FLAG)
!     styles->Desk = nptr->Desk;
!   if(nptr->off_flags & BW_FLAG)
!     styles->border_width = nptr->border_width;
!   if(nptr->off_flags & FORE_COLOR_FLAG)
!     styles->ForeColor = nptr->ForeColor;
!   if(nptr->off_flags & BACK_COLOR_FLAG)
!     styles->BackColor = nptr->BackColor;
!   if(nptr->off_flags & NOBW_FLAG)
!     styles->resize_width = nptr->resize_width;
!   styles->on_flags |= nptr->off_flags;  /* combine on and off flags */
!   styles->on_flags &= ~(nptr->on_flags);
!   styles->on_buttons |= nptr->off_buttons; /* combine buttons */
!   styles->on_buttons &= ~(nptr->on_buttons);
!   /* Note, only one style cmd can define a windows iconboxes,
!      the last one encountered. */
!   if(nptr->IconBoxes != NULL) {         /* If style has iconboxes */
!     styles->IconBoxes = nptr->IconBoxes; /* copy it */
!   }
!   return;                               /* return */
  }
*** fvwm/builtins.c.orig	Sun Oct  5 17:12:44 1997
--- fvwm/builtins.c	Sun Oct  5 17:16:48 1997
***************
*** 700,705 ****
--- 700,706 ----
  void raise_function(XEvent *eventp,Window w,FvwmWindow *tmp_win,
  		    unsigned long context, char *action, int *Module)
  {
+   name_list styles;                     /* place for merged styles */
    char *junk, *junkC;
    unsigned long junkN;
    int junkD, method, BoxJunk[4];
***************
*** 710,725 ****
    if(tmp_win)
      RaiseWindow(tmp_win);
  
!   if (LookInList(Scr.TheList,tmp_win->name, &tmp_win->class, &junk,
! #ifdef MINI_ICONS
!                  &junk,
! #endif
! #ifdef USEDECOR
! 		 &junkC,
! #endif
! 		 &junkD, &junkD, &junkD, &junkC, &junkC, &junkN,
! 		 BoxJunk,  &method)& STAYSONTOP_FLAG)
      tmp_win->flags |= ONTOP;
    KeepOnTop();
  }
  
--- 711,720 ----
    if(tmp_win)
      RaiseWindow(tmp_win);
  
!   LookInList(tmp_win, &styles);         /* get merged styles */
!   if (styles.on_flags & STAYSONTOP_FLAG) {
      tmp_win->flags |= ONTOP;
+   }
    KeepOnTop();
  }
  
***************
*** 1129,1137 ****
  void raiselower_func(XEvent *eventp,Window w,FvwmWindow *tmp_win,
  		     unsigned long context, char *action,int *Module)
  {
!   char *junk, *junkC;
!   unsigned long junkN;
!   int junkD,method, BoxJunk[4];
  
    if (DeferExecution(eventp,&w,&tmp_win,&context, SELECT,ButtonRelease))
      return;
--- 1124,1130 ----
  void raiselower_func(XEvent *eventp,Window w,FvwmWindow *tmp_win,
  		     unsigned long context, char *action,int *Module)
  {
!   name_list styles;
  
    if (DeferExecution(eventp,&w,&tmp_win,&context, SELECT,ButtonRelease))
      return;
***************
*** 1147,1162 ****
    else
    {
      RaiseWindow(tmp_win);
!     if (LookInList(Scr.TheList,tmp_win->name, &tmp_win->class,&junk,
! #ifdef MINI_ICONS
!                    &junk,
! #endif
! #ifdef USEDECOR
! 		   &junkC,
! #endif
!                    &junkD,&junkD, &junkD, &junkC,&junkC,&junkN,BoxJunk,
!                    &method)&STAYSONTOP_FLAG)
!       tmp_win->flags |= ONTOP;	    
      KeepOnTop();
    }
  }
--- 1140,1149 ----
    else
    {
      RaiseWindow(tmp_win);
!     LookInList(tmp_win, &styles);       /* get merged styles */
!     if (styles.on_flags & STAYSONTOP_FLAG) {
!       tmp_win->flags |= ONTOP;
!     }
      KeepOnTop();
    }
  }

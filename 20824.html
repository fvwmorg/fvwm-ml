<?xml version="1.0" encoding="us-ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="generator" content="hypermail 2.3.0, see http://www.hypermail-project.org/" />
<title>RE: FVWM: fvwm 2.0.46: patches and bugs: NEW PATCH from Grant McDorman on 1997-08-27 (fvwm-users)</title>
<meta name="Author" content="Grant McDorman (grant_at_isgtec.com)" />
<meta name="Subject" content="RE: FVWM: fvwm 2.0.46: patches and bugs: NEW PATCH" />
<meta name="Date" content="1997-08-27" />
<style type="text/css">
/*<![CDATA[*/
/* To be incorporated in the main stylesheet, don't code it in hypermail! */
body {color: black; background: #ffffff}
dfn {font-weight: bold;}
pre { background-color:inherit;}
.head { border-bottom:1px solid black;}
.foot { border-top:1px solid black;}
th {font-style:italic;}
table { margin-left:2em;}map ul {list-style:none;}
#mid { font-size:0.9em;}
#received { float:right;}
address { font-style:inherit ;}
/*]]>*/
.quotelev1 {color : #990099}
.quotelev2 {color : #ff7700}
.quotelev3 {color : #007799}
.quotelev4 {color : #95c500}
.period {font-weight: bold}
</style>
</head>
<body>
<div class="head">
<h1>RE: FVWM: fvwm 2.0.46: patches and bugs: NEW PATCH</h1>
<!-- received="Wed Aug 27 16:14:41 1997" -->
<!-- isoreceived="19970827151441" -->
<!-- sent="Wed, 27 Aug 1997 17:03:47 -0400 (EDT)" -->
<!-- isosent="19970827210347" -->
<!-- name="Grant McDorman" -->
<!-- email="grant_at_isgtec.com" -->
<!-- subject="RE: FVWM: fvwm 2.0.46: patches and bugs: NEW PATCH" -->
<!-- id="XFMail.970827170347.grant_at_isgtec.com" -->
<!-- charset="us-ascii" -->
<!-- inreplyto="XFMail.970826143102.grant_at_isgtec.com" -->
<!-- expires="-1" -->
<map id="navbar" name="navbar">
<ul class="links">
<li>
<dfn>This message</dfn>:
[ <a href="#start20824" name="options1" id="options1" tabindex="1">Message body</a> ]
 [ More options (<a href="#options2">top</a>, <a href="#options3">bottom</a>) ]
</li>
<li>
<dfn>Related messages</dfn>:
<!-- unext="start" -->
[ <a href="20825.html" accesskey="d" title="Martin Cartwright: &quot;Re: FVWM: pager balloons&quot;">Next message</a> ]
[ <a href="20823.html" title="Broc Stirton: &quot;Re: FVWM: Another question about starting Aps&quot;">Previous message</a> ]
[ <a href="20801.html" title="Grant McDorman: &quot;FVWM: fvwm 2.0.46: patches and bugs&quot;">In reply to</a> ]
<!-- unextthread="start" -->
[ <a href="20827.html" accesskey="t" title="Bruce Stephens: &quot;Re: FVWM: fvwm 2.0.46: patches and bugs: NEW PATCH&quot;">Next in thread</a> ]
 [ <a href="#replies">Replies</a> ]
<!-- ureply="end" -->
</li>
</ul>
</map>
<ul class="links">
<li><a name="options2" id="options2"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg20824" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg20824" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg20824" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg20824" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</div>
<!-- body="start" -->
<div class="mail">
<address class="headers">
<span id="from">
<dfn>From</dfn>: Grant McDorman &lt;<a href="mailto:grant_at_isgtec.com?Subject=RE%3A%20FVWM%3A%20fvwm%202.0.46%3A%20patches%20and%20bugs%3A%20NEW%20PATCH">grant_at_isgtec.com</a>&gt;
</span><br />
<span id="date"><dfn>Date</dfn>: Wed, 27 Aug 1997 17:03:47 -0400 (EDT)</span><br />
</address>
<br />
-----BEGIN PGP SIGNED MESSAGE-----
<br />
<br />Okay, let's try this again.
<br />
<br />The patch I sent out yesterday was flawed:
<br />
&nbsp;&nbsp;- the colourmap patch (24 bit truecolor) didn't work
<br />
&nbsp;&nbsp;- the patch to FvwmTaskBar was broken (I did not properly setup for
<br />
&nbsp;&nbsp;&nbsp;&nbsp;select() on the pipe)
<br />
&nbsp;&nbsp;- the click-to-focus patch used the wrong context if the window clicked on
<br />
&nbsp;&nbsp;&nbsp;&nbsp;didn't have the focus
<br />
<br />I also have two new patches:
<br />
&nbsp;&nbsp;&nbsp;1) in misc.c, window raising code now handles transients of transients
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(an outstanding defect, apparently)
<br />
&nbsp;&nbsp;&nbsp;2) FvwmTaskBar now gets the configuration from fvwm instead of trying to
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read fvwm's configuration file directly. This means that it will work
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for preprocessed (FvwmM4/FvwmCpp) and dynamic configuration.
<br />
<br />A revised patch is attached. If you applied the patch I sent out yesterday,
<br />
reverse it (patch -R) or start with a clean fvwm source and then apply the
<br />
attached version.
<br />
<br />Note that I am *not* the author of FvwmTaskBar. The fixes I am providing for it
<br />
are just to help.
<br />
<br />On 26-Aug-97 18:31:02 Grant McDorman wrote:
<br />
<em class="quotelev1">&gt; -----BEGIN PGP SIGNED MESSAGE-----
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; I have just finished installing - and patching - 2.0.46.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; The patches (attached) are as follows:
</em><br />
<em class="quotelev1">&gt;    modules:
</em><br />
<em class="quotelev1">&gt;       FvwmWinList:  do not call ShutMeDown in DeadPipe, just exit (to avoid
</em><br />
<em class="quotelev1">&gt;                     FvwmWinList looping)
</em><br />
<em class="quotelev1">&gt;       FvwmAudio:    ditto
</em><br />
<em class="quotelev1">&gt;       FvwmIconBox:  ditto, may need more work if the XDeleteProperty is
</em><br />
<em class="quotelev1">&gt; needed
</em><br />
<em class="quotelev1">&gt;       FvwmIconMan:  ditto
</em><br />
<em class="quotelev1">&gt;       FvwmButtons:  do not do X calls in signal handling; also, allow
</em><br />
<em class="quotelev1">&gt;                     &quot;swallowmodule&quot; as well as &quot;swallow&quot; in FvwmGoodStuff
</em><br />
<em class="quotelev1">&gt;                     compatiblity [this patch previously submitted against
</em><br />
<em class="quotelev1">&gt;                     2.0.43]
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt;    fvwm:
</em><br />
<em class="quotelev1">&gt;      colormaps.c: If, on Sun systems, TRUECOLOR_ALWAYS_INSTALLED is defined,
</em><br />
<em class="quotelev1">&gt;                   do not install a 24-bit TrueColor colormap. (Despite what
</em><br />
<em class="quotelev1">&gt;                   the server says, it is always installed.)
</em><br />
<em class="quotelev1">&gt;      add_window.c: Instead of doing button grabs for click-to-focus using no
</em><br />
<em class="quotelev1">&gt;                   modifiers and Caps Lock, use AnyModifer
</em><br />
<em class="quotelev1">&gt;      events.c:    Button press handing: Check for user-defined button action
</em><br />
<em class="quotelev1">&gt;                   first, then allow click-to-focus/click-to-raise with any
</em><br />
<em class="quotelev1">&gt;                   modifier.
</em><br />
<em class="quotelev1">&gt;      placement.c: If a transient has no position specified, fall back to
</em><br />
<em class="quotelev1">&gt;                   random/smart placement (as per configuration) instead of
</em><br />
<em class="quotelev1">&gt;                   placing the transient at 0,0
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt;    extras:
</em><br />
<em class="quotelev1">&gt;      FvwmTaskBar: fixes for signal handling like those above
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; Other &quot;extras&quot; programs require fixes for signal handling, including (at
</em><br />
<em class="quotelev1">&gt; least)
</em><br />
<em class="quotelev1">&gt; FvwmWharf. If these programs are not fixed, they can go into a loop when fvwm
</em><br />
<em class="quotelev1">&gt; is terminated or the X server reset (i.e. logout). I would suggest these
</em><br />
<em class="quotelev1">&gt; programs be removed from the release, or at least have a very strong warning
</em><br />
<em class="quotelev1">&gt; attached, until they are fixed.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; Grant McDorman &lt;grant_at_isgtec.com&gt;
</em><br />
<em class="quotelev1">&gt; ISG Technologies, Inc.  <a href="http://www.isgtec.com">http://www.isgtec.com</a>
</em><br />
<em class="quotelev1">&gt; Mississauga, Ontario, Canada
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; -----BEGIN PGP SIGNATURE-----
</em><br />
<em class="quotelev1">&gt; Version: 2.6.2
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; iQBVAwUBNAMg5UDmya2cFZ8ZAQEiOAIAuWYub8sUblDwYN5GkyL3NoYc1wtq0gVI
</em><br />
<em class="quotelev1">&gt; 559BZRWU6ehBzj+CWv9Ih/YitA6IVT8JVOtmobpAHxWFHeMlbIhjig==
</em><br />
<em class="quotelev1">&gt; =ikmu
</em><br />
<em class="quotelev1">&gt; -----END PGP SIGNATURE-----
</em><br />
<br />Grant McDorman &lt;grant_at_isgtec.com&gt;
<br />
ISG Technologies, Inc.  <a href="http://www.isgtec.com">http://www.isgtec.com</a>
<br />
Mississauga, Ontario, Canada
<br />
<br /><br />-----BEGIN PGP SIGNATURE-----
<br />
Version: 2.6.2
<br />
<br />iQBVAwUBNASWMUDmya2cFZ8ZAQH71gH9Fq5Ki42UBbE56XwXbyOegREthPHeueAY
<br />
m1NE0PToB9Y8/udeFo+8aZxzCxl6jup7Gw1vSuqyCZvyBSRWVmNKEw==
<br />
=dO8u
<br />
-----END PGP SIGNATURE-----
<br />
<br /><br />
*** fvwm-2.0.46/modules/FvwmWinList/FvwmWinList.c.orig	Wed Aug  6 16:19:28 1997
<br />
--- fvwm-2.0.46/modules/FvwmWinList/FvwmWinList.c	Tue Aug 26 11:56:22 1997
<br />
***************
<br />
*** 457,463 ****
<br />
&nbsp;&nbsp;&nbsp;**********************************************************************/
<br />
&nbsp;&nbsp;void DeadPipe(int nonsense)
<br />
&nbsp;&nbsp;{
<br />
!   ShutMeDown(1);
<br />
&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;/*****************************************************************************
<br />
*
<br />
--- 457,467 ----
<br />
&nbsp;&nbsp;&nbsp;**********************************************************************/
<br />
&nbsp;&nbsp;void DeadPipe(int nonsense)
<br />
&nbsp;&nbsp;{
<br />
!     /*
<br />
!      * do not call ShutMeDown, it may make X calls which are not allowed
<br />
!      * in a signal hander.
<br />
!      */
<br />
!   exit(1);
<br />
&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;/*****************************************************************************
<br />
*
<br />
*** fvwm-2.0.46/modules/FvwmAudio/FvwmAudio.c.orig	Fri Jan 17 11:10:49 1997
<br />
--- fvwm-2.0.46/modules/FvwmAudio/FvwmAudio.c	Tue Aug 26 11:48:53 1997
<br />
***************
<br />
*** 469,474 ****
<br />
--- 469,479 ----
<br />
&nbsp;&nbsp;&nbsp;***********************************************************************/
<br />
&nbsp;&nbsp;void DeadPipe(int nonsense)
<br />
&nbsp;&nbsp;{
<br />
+     /*
<br />
+      * In most cases, the only legal operation here is to exit. However,
<br />
+      * for this module done(0) is acceptable since all done does is
<br />
+      * to play an audio sample [see below].
<br />
+      */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done(0);
<br />
&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
*** fvwm-2.0.46/modules/FvwmIconBox/FvwmIconBox.c.orig	Thu Jan  2 15:19:31 1997
<br />
--- fvwm-2.0.46/modules/FvwmIconBox/FvwmIconBox.c	Tue Aug 26 11:51:38 1997
<br />
***************
<br />
*** 1419,1427 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpi = tmpi-&gt;next;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freeitem(tmpi2, 0);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
!   if ((local_flags &amp; SETWMICONSIZE))
<br />
!     XDeleteProperty(dpy, Root, XA_WM_ICON_SIZE); 
<br />
!   XSync(dpy,0);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;exit(0);
<br />
&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
--- 1419,1431 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpi = tmpi-&gt;next;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freeitem(tmpi2, 0);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
!   /*
<br />
!    * This cannot be done in a signal handler.
<br />
!    */
<br />
! /*  if ((local_flags &amp; SETWMICONSIZE))
<br />
!  *   XDeleteProperty(dpy, Root, XA_WM_ICON_SIZE); 
<br />
!  * XSync(dpy,0);
<br />
!  */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;exit(0);
<br />
&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
*** fvwm-2.0.46/modules/FvwmButtons/FvwmButtons.c.orig	Thu Jun 26 17:32:31 1997
<br />
--- fvwm-2.0.46/modules/FvwmButtons/FvwmButtons.c	Tue Aug 26 11:46:29 1997
<br />
***************
<br />
*** 27,32 ****
<br />
--- 27,33 ----
<br />
&nbsp;&nbsp;#include &lt;string.h&gt;
<br />
&nbsp;&nbsp;#include &lt;sys/wait.h&gt;
<br />
&nbsp;&nbsp;#include &lt;sys/time.h&gt;
<br />
+ #include &lt;sys/stat.h&gt;
<br />
&nbsp;&nbsp;#if defined ___AIX || defined _AIX || defined __QNX__ || defined ___AIXV3 || d
<br />
efined AIXV3 || defined _SEQUENT_
<br />
&nbsp;&nbsp;#include &lt;sys/select.h&gt;
<br />
&nbsp;&nbsp;#endif
<br />
***************
<br />
*** 78,83 ****
<br />
--- 79,85 ----
<br />
&nbsp;&nbsp;/* ------------------------------ prototypes ------------------------------- *
<br />
/
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;void DeadPipe(int nonsense);
<br />
+ void CleanUp(void);
<br />
&nbsp;&nbsp;void SetButtonSize(button_info*,int,int);
<br />
&nbsp;&nbsp;/* main */
<br />
&nbsp;&nbsp;void Loop(void);
<br />
***************
<br />
*** 126,131 ****
<br />
--- 128,135 ----
<br />
&nbsp;&nbsp;GC  NormalGC;
<br />
&nbsp;&nbsp;int Width,Height;
<br />
&nbsp;&nbsp;
<br />
+ int running = 1;
<br />
+ 
<br />
&nbsp;&nbsp;int x= -30000,y= -30000,w= -1,h= -1,gravity = NorthWestGravity;
<br />
&nbsp;&nbsp;int new_desk = 0;
<br />
&nbsp;&nbsp;int ready = 0;
<br />
***************
<br />
*** 173,185 ****
<br />
&nbsp;&nbsp;**/
<br />
&nbsp;&nbsp;void DeadPipe(int whatever)
<br />
&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;button_info *b,*ub=UberButton;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;int button=-1;
<br />
&nbsp;&nbsp;
<br />
-   signal(SIGPIPE, SIG_IGN);/* Xsync may cause SIGPIPE */
<br />
- 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;XSync(Dpy,0); /* Wait for thing to settle down a bit */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;XGrabServer(Dpy); /* We don't want interference right now */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;while(NextButton(&amp;ub,&amp;b,&amp;button,0))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* delete swallowed windows */
<br />
--- 177,220 ----
<br />
&nbsp;&nbsp;**/
<br />
&nbsp;&nbsp;void DeadPipe(int whatever)
<br />
&nbsp;&nbsp;{
<br />
+   struct stat buf;
<br />
+     
<br />
+   /*
<br />
+    * If a SIGPIPE arrives during this operation, just exit.
<br />
+    *  - the signal will probably because the server is shutting
<br />
+    *    down. Attempting to do any further processing is useless
<br />
+    *    and may in fact, on some platforms, put the process into
<br />
+    *    a tight loop (if SIGPIPE is ignored).
<br />
+    * 22 July 1996 GRM.
<br />
+    * 
<br />
+    * Further investigation: XSync may loop *without* causing a SIGPIPE.
<br />
+    * This may be because the connection is dead, or because of the
<br />
+    * fact that X operations in signal handlers are discouraged.
<br />
+    * 
<br />
+    * In order to cover all the bases, then, this function will now
<br />
+    * set a global flag which will cause the main loop to stop.
<br />
+    *
<br />
+    * SIGPIPE is reset to DeadPipe, as well.
<br />
+    */
<br />
+   signal(SIGPIPE, DeadPipe);
<br />
+ 
<br />
+   /*
<br />
+    * Try to check status of X connection.
<br />
+    */
<br />
+   if (fstat(XConnectionNumber(Dpy), &amp;buf) == -1)
<br />
+       exit(0);
<br />
+   
<br />
+   running = 0;
<br />
+ }
<br />
+ 
<br />
+ void CleanUp(void)
<br />
+ {
<br />
&nbsp;&nbsp;&nbsp;&nbsp;button_info *b,*ub=UberButton;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;int button=-1;
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;XSync(Dpy,0); /* Wait for thing to settle down a bit */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;XGrabServer(Dpy); /* We don't want interference right now */
<br />
+ 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;while(NextButton(&amp;ub,&amp;b,&amp;button,0))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* delete swallowed windows */
<br />
***************
<br />
*** 587,593 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;int ex=10000,ey=10000,ex2=0,ey2=0;
<br />
&nbsp;&nbsp;#endif
<br />
&nbsp;&nbsp;
<br />
!   while(1)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(My_XNextEvent(Dpy,&amp;Event))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
--- 622,628 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;int ex=10000,ey=10000,ex2=0,ey2=0;
<br />
&nbsp;&nbsp;#endif
<br />
&nbsp;&nbsp;
<br />
!   while(running)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(My_XNextEvent(Dpy,&amp;Event))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
***************
<br />
*** 814,819 ****
<br />
--- 849,855 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
+     CleanUp();
<br />
&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;/**
<br />
*** fvwm-2.0.46/modules/FvwmButtons/parse.c.orig	Thu Jun 26 17:32:33 1997
<br />
--- fvwm-2.0.46/modules/FvwmButtons/parse.c	Tue Aug 26 11:44:18 1997
<br />
***************
<br />
*** 670,675 ****
<br />
--- 670,682 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s+=7;
<br />
+       /*
<br />
+        * Swallow old 'swallowmodule' command
<br />
+        */
<br />
+       if (mystrncasecmp(s,&quot;module&quot;,6)==0)
<br />
+       {
<br />
+           s+=6;
<br />
+       }
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;hangon=seekright(&amp;s);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;flags|=(b_Swallow|b_Hangon);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b-&gt;swallow|=1;
<br />
*** fvwm-2.0.46/modules/FvwmIconMan/FvwmIconMan.c.orig	Wed Jul 16 21:31:21 1997
<br />
--- fvwm-2.0.46/modules/FvwmIconMan/FvwmIconMan.c	Tue Aug 26 11:53:22 1997
<br />
***************
<br />
*** 96,102 ****
<br />
&nbsp;&nbsp;void DeadPipe (int nothing)
<br />
&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;ConsoleDebug (CORE, &quot;Bye Bye\n&quot;);
<br />
!   ShutMeDown (0);
<br />
&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;void SendFvwmPipe (char *message,unsigned long window)
<br />
--- 96,107 ----
<br />
&nbsp;&nbsp;void DeadPipe (int nothing)
<br />
&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;ConsoleDebug (CORE, &quot;Bye Bye\n&quot;);
<br />
!   /*
<br />
!    * ShutMeDown is not called because most operations, especially X
<br />
!    * calls, are not allowed in signal handlers. Currently, of course,
<br />
!    * ShutMeDown doesn't do anything significant, but it may in future.
<br />
!    */
<br />
!   exit (0);
<br />
&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;void SendFvwmPipe (char *message,unsigned long window)
<br />
*** fvwm-2.0.46/fvwm/colormaps.c.orig	Fri Apr 28 08:38:32 1995
<br />
--- fvwm-2.0.46/fvwm/colormaps.c	Tue Aug 26 15:15:14 1997
<br />
***************
<br />
*** 152,159 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(w == tmp-&gt;w)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThisWinInstalled = True;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XGetWindowAttributes(dpy,w,&amp;attributes);
<br />
! 	  
<br />
! 	  if(last_cmap != attributes.colormap)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last_cmap = attributes.colormap;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XInstallColormap(dpy,attributes.colormap);    
<br />
--- 152,168 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(w == tmp-&gt;w)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThisWinInstalled = True;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XGetWindowAttributes(dpy,w,&amp;attributes);
<br />
! 
<br />
!             /*
<br />
!              * On Sun X servers, don't install 24 bit TrueColor colourmaps.
<br />
!              * Despite what the server says, these colourmaps are always
<br />
!              * installed.
<br />
!              */
<br />
! 	  if(last_cmap != attributes.colormap
<br />
! #if defined(sun) &amp;&amp; defined(TRUECOLOR_ALWAYS_INSTALLED)
<br />
!              &amp;&amp; !(attributes.depth == 24 &amp;&amp; attributes.visual-&gt;class == TrueCo
<br />
lor)
<br />
! #endif
<br />
!              )
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last_cmap = attributes.colormap;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XInstallColormap(dpy,attributes.colormap);    
<br />
***************
<br />
*** 163,169 ****
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if(!ThisWinInstalled)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
!       if(last_cmap != tmp-&gt;attr.colormap)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last_cmap = tmp-&gt;attr.colormap;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XInstallColormap(dpy,tmp-&gt;attr.colormap);    
<br />
--- 172,182 ----
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if(!ThisWinInstalled)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
!       if(last_cmap != tmp-&gt;attr.colormap
<br />
! #if defined(sun) &amp;&amp; defined(TRUECOLOR_ALWAYS_INSTALLED)
<br />
!          &amp;&amp; !(tmp-&gt;attr.depth == 24 &amp;&amp; tmp-&gt;attr.visual-&gt;class == TrueColor)
<br />
! #endif
<br />
!         )
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last_cmap = tmp-&gt;attr.colormap;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XInstallColormap(dpy,tmp-&gt;attr.colormap);    
<br />
*** fvwm-2.0.46/fvwm/add_window.c.orig	Wed Aug  6 15:35:12 1997
<br />
--- fvwm-2.0.46/fvwm/add_window.c	Tue Aug 26 11:25:56 1997
<br />
***************
<br />
*** 656,667 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;3;i++)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Scr.buttons2grab &amp; (1&lt;&lt;i))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
! 	    XGrabButton(dpy,(i+1),0,tmp_win-&gt;frame,True,
<br />
! 			ButtonPressMask, GrabModeSync,GrabModeAsync,None,
<br />
! 			Scr.FvwmCursors[SYS]);
<br />
! 	    XGrabButton(dpy,(i+1),LockMask,tmp_win-&gt;frame,True,
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ButtonPressMask, GrabModeSync,GrabModeAsync,None,
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scr.FvwmCursors[SYS]);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;BroadcastConfig(M_ADD_WINDOW,tmp_win);
<br />
--- 656,669 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;3;i++)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Scr.buttons2grab &amp; (1&lt;&lt;i))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
!               /* accept any modifier on this button */
<br />
! 	    XGrabButton(dpy,(i+1),AnyModifier,tmp_win-&gt;frame,True,
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ButtonPressMask, GrabModeSync,GrabModeAsync,None,
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scr.FvwmCursors[SYS]);
<br />
+ /*	    XGrabButton(dpy,(i+1),LockMask,tmp_win-&gt;frame,True,
<br />
+  *			ButtonPressMask, GrabModeSync,GrabModeAsync,None,
<br />
+  *			Scr.FvwmCursors[SYS]);
<br />
+  */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;BroadcastConfig(M_ADD_WINDOW,tmp_win);
<br />
*** fvwm-2.0.46/fvwm/decorations.c.orig	Mon Aug  4 16:52:51 1997
<br />
--- fvwm-2.0.46/fvwm/decorations.c	Tue Aug 26 11:29:57 1997
<br />
***************
<br />
*** 589,594 ****
<br />
--- 589,598 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(!(t-&gt;functions &amp; MWM_FUNC_CLOSE)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
<br />
&nbsp;&nbsp;
<br />
+   if((function == F_CLOSE)&amp;&amp;(t)&amp;&amp;
<br />
+      (!(t-&gt;functions &amp; MWM_FUNC_CLOSE)))
<br />
+     return 0;
<br />
+ 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if((function == F_DESTROY)&amp;&amp;(t)&amp;&amp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(!(t-&gt;functions &amp; MWM_FUNC_CLOSE)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
<br />
*** fvwm-2.0.46/fvwm/events.c.orig	Thu Aug  7 11:14:22 1997
<br />
--- fvwm-2.0.46/fvwm/events.c	Tue Aug 26 18:07:06 1997
<br />
***************
<br />
*** 203,211 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* window where the event occured */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if((e-&gt;type == KeyPress)&amp;&amp;(e-&gt;xkey.subwindow != None))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*w = e-&gt;xkey.subwindow;
<br />
!   
<br />
!   if((e-&gt;type == ButtonPress)&amp;&amp;(e-&gt;xbutton.subwindow != None)&amp;&amp;
<br />
!      ((e-&gt;xbutton.subwindow == t-&gt;w)||(e-&gt;xbutton.subwindow == t-&gt;Parent)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*w = e-&gt;xbutton.subwindow;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if (*w == Scr.Root)
<br />
--- 203,214 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* window where the event occured */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if((e-&gt;type == KeyPress)&amp;&amp;(e-&gt;xkey.subwindow != None))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*w = e-&gt;xkey.subwindow;
<br />
! 
<br />
!     /* Q: are these subwindow checks necessary? */
<br />
!   if((e-&gt;type == ButtonPress)&amp;&amp;(e-&gt;xbutton.subwindow != None)
<br />
! /*    &amp;&amp;((e-&gt;xbutton.subwindow == t-&gt;w)||(e-&gt;xbutton.subwindow == t-&gt;Parent)||
<br />
!       (e-&gt;xbutton.subwindow == t-&gt;title_w))*/
<br />
!     )
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*w = e-&gt;xbutton.subwindow;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if (*w == Scr.Root)
<br />
***************
<br />
*** 968,1035 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;DBUG(&quot;HandleButtonPress&quot;,&quot;Routine Entered&quot;);
<br />
&nbsp;&nbsp;
<br />
!   /* click to focus stuff goes here */
<br />
!   if((Tmp_win)&amp;&amp;(Tmp_win-&gt;flags &amp; ClickToFocus)&amp;&amp;(Tmp_win != Scr.Ungrabbed) &amp;&amp;
<br />
!      ((Event.xbutton.state&amp;
<br />
!        (ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask)) == 0))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
!     if(Tmp_win)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
!       SetFocus(Tmp_win-&gt;w,Tmp_win,1);
<br />
&nbsp;&nbsp;/* #ifdef CLICKY_MODE_1 */
<br />
!       if (Scr.ClickToFocusRaises ||
<br />
!           ((Event.xany.window != Tmp_win-&gt;w)&amp;&amp;
<br />
!            (Event.xbutton.subwindow != Tmp_win-&gt;w)&amp;&amp;
<br />
!            (Event.xany.window != Tmp_win-&gt;Parent)&amp;&amp;
<br />
!            (Event.xbutton.subwindow != Tmp_win-&gt;Parent)))
<br />
&nbsp;&nbsp;/* #endif */
<br />
!       {
<br />
!         RaiseWindow(Tmp_win);
<br />
!       }
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
!       KeepOnTop();
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Why is this here? Seems to cause breakage with
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* non-focusing windows! */
<br />
!       if(!(Tmp_win-&gt;flags &amp; ICONIFIED))
<br />
!       {
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XSync(dpy,0);
<br />
!         /* pass click event to just clicked to focus window? */
<br />
!         if (Scr.ClickToFocusPassesClick)
<br />
!           XAllowEvents(dpy,ReplayPointer,CurrentTime);
<br />
!         else /* don't pass click to just focused window */
<br />
!           XAllowEvents(dpy,AsyncPointer,CurrentTime);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XSync(dpy,0);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<br />
-       }
<br />
-       
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
-   else if ((Tmp_win) &amp;&amp; !(Tmp_win-&gt;flags &amp; ClickToFocus) &amp;&amp;
<br />
-            (Event.xbutton.window == Tmp_win-&gt;frame) &amp;&amp;
<br />
-           Scr.MouseFocusClickRaises)
<br />
-   {
<br />
-     if (Tmp_win != Scr.LastWindowRaised &amp;&amp;
<br />
-         (Event.xbutton.state &amp;
<br />
-          (ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask)) == 0 &amp;&amp;
<br />
-         GetContext(Tmp_win,&amp;Event, &amp;PressedW) == C_WINDOW)
<br />
-     {
<br />
-       RaiseWindow(Tmp_win);
<br />
-       KeepOnTop();
<br />
-     }
<br />
-     XSync(dpy,0);
<br />
-     XAllowEvents(dpy,ReplayPointer,CurrentTime);
<br />
-     XSync(dpy,0);
<br />
-     return;
<br />
-   }
<br />
&nbsp;&nbsp;
<br />
-   XSync(dpy,0);
<br />
-   XAllowEvents(dpy,ReplayPointer,CurrentTime);
<br />
-   XSync(dpy,0);
<br />
-   
<br />
-   Context = GetContext(Tmp_win,&amp;Event, &amp;PressedW);
<br />
-   LocalContext = Context;
<br />
-   x= PressedW;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if(Context == C_TITLE)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetTitleBar(Tmp_win,(Scr.Hilite == Tmp_win),False);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;else
<br />
--- 971,1061 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;DBUG(&quot;HandleButtonPress&quot;,&quot;Routine Entered&quot;);
<br />
&nbsp;&nbsp;
<br />
!   /*
<br />
!    * First, look for button bindings.
<br />
!    */
<br />
!   Context = GetContext(Tmp_win,&amp;Event, &amp;PressedW);
<br />
!   LocalContext = Context;
<br />
!   x= PressedW;
<br />
! 
<br />
!   /* we have to execute a function or pop up a menu
<br />
!    */
<br />
!   
<br />
!   modifier = (Event.xbutton.state &amp; mods_used);
<br />
!   /* need to search for an appropriate mouse binding */
<br />
!   for (MouseEntry = Scr.AllBindings; MouseEntry != NULL;
<br />
!        MouseEntry= MouseEntry-&gt;NextBinding)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
!     if(((MouseEntry-&gt;Button_Key == Event.xbutton.button)||
<br />
!         (MouseEntry-&gt;Button_Key == 0))&amp;&amp;
<br />
!        (MouseEntry-&gt;Context &amp; Context)&amp;&amp;
<br />
!        ((MouseEntry-&gt;Modifier == AnyModifier)||
<br />
!         (MouseEntry-&gt;Modifier == (modifier&amp; (~LockMask))))&amp;&amp;
<br />
!        (MouseEntry-&gt;IsMouse == 1))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
!       /* got a match ... save it and exit loop */
<br />
!       break;
<br />
!     }
<br />
!   }
<br />
! 
<br />
!   /*
<br />
!    * do no click to focus if a mouse function was found
<br />
!    */
<br />
!   if (MouseEntry == NULL) {
<br />
!     /* click to focus stuff goes here */
<br />
!     /* any modifier is acceptable for click-to-focus */
<br />
!     if((Tmp_win)&amp;&amp;(Tmp_win-&gt;flags &amp; ClickToFocus)&amp;&amp;(Tmp_win != Scr.Ungrabbed))
<br />
!     {
<br />
!       if(Tmp_win)
<br />
!       {
<br />
!         SetFocus(Tmp_win-&gt;w,Tmp_win,1);
<br />
&nbsp;&nbsp;/* #ifdef CLICKY_MODE_1 */
<br />
!           if (Scr.ClickToFocusRaises ||
<br />
!               ((Event.xany.window != Tmp_win-&gt;w)&amp;&amp;
<br />
!                (Event.xbutton.subwindow != Tmp_win-&gt;w)&amp;&amp;
<br />
!                (Event.xany.window != Tmp_win-&gt;Parent)&amp;&amp;
<br />
!                (Event.xbutton.subwindow != Tmp_win-&gt;Parent)))
<br />
&nbsp;&nbsp;/* #endif */
<br />
!           {
<br />
!             RaiseWindow(Tmp_win);
<br />
!           }
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
!           KeepOnTop();
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Why is this here? Seems to cause breakage with
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* non-focusing windows! */
<br />
!           if(!(Tmp_win-&gt;flags &amp; ICONIFIED))
<br />
!           {
<br />
!             XSync(dpy,0);
<br />
!               /* pass click event to just clicked to focus window? */
<br />
!               if (Scr.ClickToFocusPassesClick)
<br />
!                 XAllowEvents(dpy,ReplayPointer,CurrentTime);
<br />
!               else /* don't pass click to just focused window */
<br />
!                 XAllowEvents(dpy,AsyncPointer,CurrentTime);
<br />
!               XSync(dpy,0);
<br />
!               return;
<br />
!           }
<br />
!       
<br />
!       }
<br />
!     }
<br />
!     else if ((Tmp_win) &amp;&amp; !(Tmp_win-&gt;flags &amp; ClickToFocus) &amp;&amp;
<br />
!              (Event.xbutton.window == Tmp_win-&gt;frame) &amp;&amp;
<br />
!              Scr.MouseFocusClickRaises)
<br />
!     {
<br />
!         /* click-to-raise. Again, ignore any modifiers. */
<br />
!         if (Tmp_win != Scr.LastWindowRaised &amp;&amp;
<br />
!             GetContext(Tmp_win,&amp;Event, &amp;PressedW) == C_WINDOW)
<br />
!         {
<br />
!             RaiseWindow(Tmp_win);
<br />
!             KeepOnTop();
<br />
!         }
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XSync(dpy,0);
<br />
!         XAllowEvents(dpy,ReplayPointer,CurrentTime);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XSync(dpy,0);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if(Context == C_TITLE)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetTitleBar(Tmp_win,(Scr.Hilite == Tmp_win),False);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;else
<br />
***************
<br />
*** 1037,1062 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;ButtonWindow = Tmp_win;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;
<br />
!   /* we have to execute a function or pop up a menu
<br />
!    */
<br />
!   
<br />
!   modifier = (Event.xbutton.state &amp; mods_used);
<br />
!   /* need to search for an appropriate mouse binding */
<br />
!   for (MouseEntry = Scr.AllBindings; MouseEntry != NULL;
<br />
!        MouseEntry= MouseEntry-&gt;NextBinding)
<br />
!   {
<br />
!     if(((MouseEntry-&gt;Button_Key == Event.xbutton.button)||
<br />
!         (MouseEntry-&gt;Button_Key == 0))&amp;&amp;
<br />
!        (MouseEntry-&gt;Context &amp; Context)&amp;&amp;
<br />
!        ((MouseEntry-&gt;Modifier == AnyModifier)||
<br />
!         (MouseEntry-&gt;Modifier == (modifier&amp; (~LockMask))))&amp;&amp;
<br />
!        (MouseEntry-&gt;IsMouse == 1))
<br />
!     {
<br />
!       /* got a match, now process it */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExecuteFunction(MouseEntry-&gt;Action,Tmp_win, &amp;Event,Context,-1);
<br />
!       break;
<br />
!     }
<br />
!   }
<br />
&nbsp;&nbsp;&nbsp;&nbsp;PressedW = None;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if(LocalContext!=C_TITLE)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetBorder(ButtonWindow,(Scr.Hilite == ButtonWindow),True,True,x);
<br />
--- 1063,1075 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;ButtonWindow = Tmp_win;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;
<br />
!   XSync(dpy,0);
<br />
!   XAllowEvents(dpy,ReplayPointer,CurrentTime);
<br />
!   XSync(dpy,0);
<br />
! 
<br />
!   if (MouseEntry != NULL)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExecuteFunction(MouseEntry-&gt;Action,Tmp_win, &amp;Event,Context,-1);
<br />
! 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;PressedW = None;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if(LocalContext!=C_TITLE)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetBorder(ButtonWindow,(Scr.Hilite == ButtonWindow),True,True,x);
<br />
*** fvwm-2.0.46/fvwm/placement.c.orig	Fri Jan 17 09:39:21 1997
<br />
--- fvwm-2.0.46/fvwm/placement.c	Tue Aug 26 14:24:49 1997
<br />
***************
<br />
*** 396,402 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;/* Desk has been selected, now pick a location for the window */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;/*
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*  If
<br />
!    *     o  the window is a transient, or
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*     o  a USPosition was requested
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 
<br />
--- 396,402 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;/* Desk has been selected, now pick a location for the window */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;/*
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*  If
<br />
!    *     o  the window is a transient with a position, or
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*     o  a USPosition was requested
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 
<br />
***************
<br />
*** 405,411 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*   If RandomPlacement was specified,
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*       then place the window in a psuedo-random location
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
<br />
!   if (!(tmp_win-&gt;flags &amp; TRANSIENT) &amp;&amp; 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!(tmp_win-&gt;hints.flags &amp; USPosition) &amp;&amp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((tflag &amp; NO_PPOSITION_FLAG)||
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!(tmp_win-&gt;hints.flags &amp; PPosition)) &amp;&amp;
<br />
--- 405,411 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*   If RandomPlacement was specified,
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*       then place the window in a psuedo-random location
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
<br />
!   if (!((tmp_win-&gt;flags &amp; TRANSIENT) &amp;&amp; (tmp_win-&gt;hints.flags &amp; PPosition)) &amp;&amp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!(tmp_win-&gt;hints.flags &amp; USPosition) &amp;&amp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((tflag &amp; NO_PPOSITION_FLAG)||
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!(tmp_win-&gt;hints.flags &amp; PPosition)) &amp;&amp;
<br />
***************
<br />
*** 415,421 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tmp_win-&gt;wmhints-&gt;initial_state == IconicState)) )
<br />
&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Get user's window placement, unless RandomPlacement is specified */   
<br />
!     if(tflag &amp; RANDOM_PLACE_FLAG)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(tflag &amp; SMART_PLACE_FLAG)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SmartPlacement(tmp_win,tmp_win-&gt;frame_width+2*tmp_win-&gt;bw,
<br />
--- 415,421 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tmp_win-&gt;wmhints-&gt;initial_state == IconicState)) )
<br />
&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Get user's window placement, unless RandomPlacement is specified */   
<br />
!     if(tflag &amp; RANDOM_PLACE_FLAG || (tmp_win-&gt;flags &amp; TRANSIENT))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(tflag &amp; SMART_PLACE_FLAG)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SmartPlacement(tmp_win,tmp_win-&gt;frame_width+2*tmp_win-&gt;bw,
<br />
*** fvwm-2.0.46/fvwm/misc.c.orig	Tue Aug 26 17:02:45 1997
<br />
--- fvwm-2.0.46/fvwm/misc.c	Tue Aug 26 17:03:38 1997
<br />
***************
<br />
*** 588,608 ****
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;
<br />
! void RaiseWindow(FvwmWindow *t)
<br />
&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;FvwmWindow *t2;
<br />
!   int count, i;
<br />
!   Window *wins;
<br />
&nbsp;&nbsp;
<br />
-   /* raise the target, at least */
<br />
-   count = 1;
<br />
-   Broadcast(M_RAISE_WINDOW,3,t-&gt;w,t-&gt;frame,(unsigned long)t,0,0,0,0);
<br />
-   
<br />
&nbsp;&nbsp;&nbsp;&nbsp;for (t2 = Scr.FvwmRoot.next; t2 != NULL; t2 = t2-&gt;next)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
!       if(t2-&gt;flags &amp; ONTOP)
<br />
! 	count++;
<br />
!       if((t2-&gt;flags &amp; TRANSIENT) &amp;&amp;(t2-&gt;transientfor == t-&gt;w)&amp;&amp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t2 != t))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
<br />
--- 588,606 ----
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;
<br />
! /*
<br />
!  * Count all transients, direct or indirect, for window 't'
<br />
!  */
<br />
! static int CountTransientsFor(FvwmWindow *t)
<br />
&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;FvwmWindow *t2;
<br />
!   Window      transientfor;
<br />
!   int         count = 0;
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;for (t2 = Scr.FvwmRoot.next; t2 != NULL; t2 = t2-&gt;next)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
!       if(!(t2-&gt;flags &amp; ONTOP) &amp;&amp; 
<br />
!          (t2-&gt;flags &amp; TRANSIENT) &amp;&amp;(t2-&gt;transientfor == t-&gt;w)&amp;&amp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t2 != t))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
<br />
***************
<br />
*** 611,619 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((t2-&gt;flags &amp; ICONIFIED)&amp;&amp;(!(t2-&gt;flags &amp; SUPPRESSICON)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count += 2;
<br />
! 	    }	  
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if ((t-&gt;flags &amp; ICONIFIED)&amp;&amp;(!(t-&gt;flags &amp; SUPPRESSICON)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count += 2;
<br />
--- 609,702 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((t2-&gt;flags &amp; ICONIFIED)&amp;&amp;(!(t2-&gt;flags &amp; SUPPRESSICON)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count += 2;
<br />
! 	    }
<br />
!           /*
<br />
!            * Also count this transient window's own transients
<br />
!            * To avoid loops, temporarily destroy the transientfor.
<br />
!            */
<br />
!           transientfor = t2-&gt;transientfor;
<br />
!           t2-&gt;transientfor = None;
<br />
!           count += CountTransientsFor(t2);
<br />
!           t2-&gt;transientfor = transientfor;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
+   return count;
<br />
+ }
<br />
+ 
<br />
+ /*
<br />
+  * Fill in array with transients for window 't'.
<br />
+  */
<br />
+ static void GetTransientsFor(FvwmWindow *t, Window *wins, int *i)
<br />
+ {
<br />
+   FvwmWindow *t2;
<br />
+   Window      transientfor;
<br />
+ 
<br />
+   for (t2 = Scr.FvwmRoot.next; t2 != NULL; t2 = t2-&gt;next)
<br />
+   {
<br />
+     if((t2-&gt;flags &amp; TRANSIENT) &amp;&amp;
<br />
+        (t2-&gt;transientfor == t-&gt;w) &amp;&amp;
<br />
+        (t2 != t) &amp;&amp;
<br />
+        (!(t2-&gt;flags &amp; ONTOP)))
<br />
+     {
<br />
+       /*
<br />
+        * Put this window's own transients in first.
<br />
+        * As above, temporarily destroy the transientfor.
<br />
+        */
<br />
+       transientfor = t2-&gt;transientfor;
<br />
+       t2-&gt;transientfor = None;
<br />
+       GetTransientsFor(t2, wins, i);
<br />
+       t2-&gt;transientfor = transientfor;
<br />
+ 
<br />
+       /*
<br />
+        * Now put in the transient itself.
<br />
+        */
<br />
+       wins[(*i)++] = t2-&gt;frame;
<br />
+       if ((t2-&gt;flags &amp; ICONIFIED)&amp;&amp;(!(t2-&gt;flags &amp; SUPPRESSICON)))
<br />
+       {
<br />
+         if(!(t2-&gt;flags &amp; NOICON_TITLE))
<br />
+           wins[(*i)++] = t2-&gt;icon_w;
<br />
+         if(!(t2-&gt;icon_pixmap_w))
<br />
+           wins[(*i)++] = t2-&gt;icon_pixmap_w;
<br />
+       }
<br />
+     }
<br />
+   }
<br />
+ }
<br />
+ 
<br />
+ /*
<br />
+  * Raise a window. Maintain transients for that window above the window
<br />
+  * (if DONT_RAISE_TRANSIENTS not defined).
<br />
+  */
<br />
+ void RaiseWindow(FvwmWindow *t)
<br />
+ {
<br />
+   FvwmWindow *t2;
<br />
+   int count, i;
<br />
+   Window *wins;
<br />
+ 
<br />
+   /*
<br />
+    * 1. Count windows that will get raised.
<br />
+    */
<br />
+ 
<br />
+   /* 1a. raise the target, at least */
<br />
+   count = 1;
<br />
+   Broadcast(M_RAISE_WINDOW,3,t-&gt;w,t-&gt;frame,(unsigned long)t,0,0,0,0);
<br />
+ 
<br />
+   /*
<br />
+    * 1b. Count on-top windows
<br />
+    */
<br />
+   for (t2 = Scr.FvwmRoot.next; t2 != NULL; t2 = t2-&gt;next)
<br />
+     {
<br />
+       if(t2-&gt;flags &amp; ONTOP)
<br />
+ 	count++;
<br />
+     }
<br />
+ 
<br />
+   /*
<br />
+    * 1c. Count transients (direct and indirect) for this window.
<br />
+    */
<br />
+   count += CountTransientsFor(t);
<br />
+ 
<br />
+   /*
<br />
+    * 1d. Count window's icon, if this window is iconified.
<br />
+    */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if ((t-&gt;flags &amp; ICONIFIED)&amp;&amp;(!(t-&gt;flags &amp; SUPPRESSICON)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count += 2;
<br />
***************
<br />
*** 623,629 ****
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;i=0;
<br />
&nbsp;&nbsp;
<br />
!   /* ONTOP windows on top */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;for (t2 = Scr.FvwmRoot.next; t2 != NULL; t2 = t2-&gt;next)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(t2-&gt;flags &amp; ONTOP)
<br />
--- 706,715 ----
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;i=0;
<br />
&nbsp;&nbsp;
<br />
!   /*
<br />
!    * 2. Collect windows in order.
<br />
!    */
<br />
!   /* 2a. ONTOP windows on top */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;for (t2 = Scr.FvwmRoot.next; t2 != NULL; t2 = t2-&gt;next)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(t2-&gt;flags &amp; ONTOP)
<br />
***************
<br />
*** 634,659 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
!   /* now raise transients */
<br />
&nbsp;&nbsp;#ifndef DONT_RAISE_TRANSIENTS
<br />
!   for (t2 = Scr.FvwmRoot.next; t2 != NULL; t2 = t2-&gt;next)
<br />
!   {
<br />
!     if((t2-&gt;flags &amp; TRANSIENT) &amp;&amp;
<br />
!        (t2-&gt;transientfor == t-&gt;w) &amp;&amp;
<br />
!        (t2 != t) &amp;&amp;
<br />
!        (!(t2-&gt;flags &amp; ONTOP)))
<br />
!     {
<br />
!       wins[i++] = t2-&gt;frame;
<br />
!       if ((t2-&gt;flags &amp; ICONIFIED)&amp;&amp;(!(t2-&gt;flags &amp; SUPPRESSICON)))
<br />
!       {
<br />
!         if(!(t2-&gt;flags &amp; NOICON_TITLE))
<br />
!           wins[i++] = t2-&gt;icon_w;
<br />
!         if(!(t2-&gt;icon_pixmap_w))
<br />
!           wins[i++] = t2-&gt;icon_pixmap_w;
<br />
!       }
<br />
!     }
<br />
!   }
<br />
&nbsp;&nbsp;#endif
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if ((t-&gt;flags &amp; ICONIFIED)&amp;&amp;(!(t-&gt;flags &amp; SUPPRESSICON)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!(t-&gt;flags &amp; NOICON_TITLE)) 
<br />
--- 720,735 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
!   /* 
<br />
!    * 2b. Transients.
<br />
!    */
<br />
&nbsp;&nbsp;#ifndef DONT_RAISE_TRANSIENTS
<br />
!     GetTransientsFor(t, wins, &amp;i);
<br />
&nbsp;&nbsp;#endif
<br />
+     
<br />
+   /*
<br />
+    * 2c. Window itself.
<br />
+    */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if ((t-&gt;flags &amp; ICONIFIED)&amp;&amp;(!(t-&gt;flags &amp; SUPPRESSICON)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;{
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!(t-&gt;flags &amp; NOICON_TITLE)) 
<br />
***************
<br />
*** 666,671 ****
<br />
--- 742,750 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if(!(t-&gt;flags &amp; ONTOP))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scr.LastWindowRaised = t;
<br />
&nbsp;&nbsp;
<br />
+   /*
<br />
+    * Raise the topmost window in the stack
<br />
+    */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if(i &gt; 0)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XRaiseWindow(dpy,wins[0]);
<br />
&nbsp;&nbsp;
<br />
*** fvwm-2.0.46/extras/FvwmTaskBar/FvwmTaskBar.c.orig	Tue Sep 24 06:54:59 1996
<br />
--- fvwm-2.0.46/extras/FvwmTaskBar/FvwmTaskBar.c	Tue Aug 26 17:34:55 1997
<br />
***************
<br />
*** 78,83 ****
<br />
--- 78,90 ----
<br />
&nbsp;&nbsp;int   Fvwm_fd[2];
<br />
&nbsp;&nbsp;int   x_fd;
<br />
&nbsp;&nbsp;
<br />
+ /* Signal handling */
<br />
+ int   signal_pipes[2];
<br />
+ enum e_SignalActions {
<br />
+     SIGNAL_DEAD_PIPE=1,
<br />
+     SIGNAL_ALARM=2
<br />
+ };
<br />
+ 
<br />
&nbsp;&nbsp;/* X related things */
<br />
&nbsp;&nbsp;Display *dpy;
<br />
&nbsp;&nbsp;Window  Root, win;
<br />
***************
<br />
*** 181,188 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;Fvwm_fd[1] = atoi(argv[2]);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;fd_width = GetFdWidth();
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;signal (SIGPIPE, DeadPipe);
<br />
!   signal (SIGALRM, Alarm);
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;SetMessageMask(Fvwm_fd,M_ADD_WINDOW | M_CONFIGURE_WINDOW | M_DESTROY_WINDOW 
<br />
|
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M_WINDOW_NAME | M_ICON_NAME | M_RES_NAME | M_DEICONIFY | M_ICONIFY |
<br />
--- 188,201 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;Fvwm_fd[1] = atoi(argv[2]);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;fd_width = GetFdWidth();
<br />
&nbsp;&nbsp;
<br />
+   /* set up signal and alarm pipes */
<br />
+   pipe(signal_pipes);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;signal (SIGPIPE, DeadPipe);
<br />
!   signal (SIGALRM, SigAlarm);
<br />
! 
<br />
!   /* Parse the config file */
<br />
!   InitList(&amp;swallowed);
<br />
!   ParseConfig(argv[3]);
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;SetMessageMask(Fvwm_fd,M_ADD_WINDOW | M_CONFIGURE_WINDOW | M_DESTROY_WINDOW 
<br />
|
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M_WINDOW_NAME | M_ICON_NAME | M_RES_NAME | M_DEICONIFY | M_ICONIFY |
<br />
***************
<br />
*** 197,206 ****
<br />
&nbsp;&nbsp;#endif
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
<br />
&nbsp;&nbsp;
<br />
-   /* Parse the config file */
<br />
-   InitList(&amp;swallowed);
<br />
-   ParseConfig(argv[3]);
<br />
- 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;/* Setup the XConnection */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;StartMeUp();
<br />
&nbsp;&nbsp;&nbsp;&nbsp;XSetErrorHandler((XErrorHandler) ErrorHandler);
<br />
--- 210,215 ----
<br />
***************
<br />
*** 235,240 ****
<br />
--- 244,250 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_ZERO(&amp;readset);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(Fvwm_fd[1], &amp;readset);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(x_fd, &amp;readset);
<br />
+     FD_SET(signal_pipes[1], &amp;readset);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XPending(dpy);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tv.tv_sec  = 0;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tv.tv_usec = 0;
<br />
***************
<br />
*** 244,249 ****
<br />
--- 254,260 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_ZERO(&amp;readset);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(Fvwm_fd[1], &amp;readset);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(x_fd, &amp;readset);
<br />
+         FD_SET(signal_pipes[1], &amp;readset);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XPending(dpy);
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tv.tv_sec  = UpdateInterval;
<br />
***************
<br />
*** 260,265 ****
<br />
--- 271,277 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_ZERO(&amp;readset);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(Fvwm_fd[1], &amp;readset);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(x_fd, &amp;readset);
<br />
+         FD_SET(signal_pipes[1], &amp;readset);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XPending(dpy);
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tv.tv_sec  = UpdateInterval;
<br />
***************
<br />
*** 281,286 ****
<br />
--- 293,314 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawGoodies();
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
+       /*
<br />
+        * signal notification handling
<br />
+        */
<br />
+     if (FD_ISSET(signal_pipes[1], &amp;readset)) {
<br />
+         char buffer[1];
<br />
+         read(signal_pipes[1], buffer, sizeof buffer);
<br />
+         switch (buffer[0]) {
<br />
+          case SIGNAL_DEAD_PIPE:
<br />
+             ShutMeDown(1);
<br />
+             break;
<br />
+             
<br />
+          case SIGNAL_ALARM:
<br />
+             Alarm();
<br />
+         }
<br />
+     }
<br />
+ 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
***************
<br />
*** 495,502 ****
<br />
&nbsp;&nbsp;&nbsp;**********************************************************************/
<br />
&nbsp;&nbsp;void DeadPipe(int nonsense)
<br />
&nbsp;&nbsp;{
<br />
!   ConsoleMessage(&quot;received SIGPIPE signal: exiting...\n&quot;);
<br />
!   ShutMeDown(1);
<br />
&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;/*****************************************************************************
<br />
*
<br />
--- 523,533 ----
<br />
&nbsp;&nbsp;&nbsp;**********************************************************************/
<br />
&nbsp;&nbsp;void DeadPipe(int nonsense)
<br />
&nbsp;&nbsp;{
<br />
!   /*
<br />
!    * Send notification to the main loop
<br />
!    */
<br />
!   static char buffer[1] = { (char) SIGNAL_DEAD_PIPE  };
<br />
!   write(signal_pipes[0], buffer, sizeof buffer);
<br />
&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;/*****************************************************************************
<br />
*
<br />
***************
<br />
*** 575,589 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;char *str;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;FILE *ptr;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;int i, j;
<br />
!    
<br />
&nbsp;&nbsp;&nbsp;&nbsp;ptr = fopen(file,&quot;r&quot;);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if (ptr == (FILE *)NULL) {
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConsoleMessage(&quot;Couldn't read configuration file (%s)...\n&quot;, file);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;tline = fgets(line,(sizeof line)-1,ptr);
<br />
- 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;while (tline != (char *)0) {
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (isspace(*tline))tline++;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (strlen(tline)&gt;1 &amp;&amp; tline[0] != '#') {
<br />
--- 606,639 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;char *str;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;FILE *ptr;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;int i, j;
<br />
! 
<br />
! #ifndef FVWM95
<br />
!     /*
<br />
!      * transfer config to a temporary file, to avoid problems with
<br />
!      * message traffic during configuration parsing
<br />
!      */
<br />
!     ptr = tmpfile();
<br />
!   if (ptr == (FILE *)NULL) {
<br />
!     ConsoleMessage(&quot;Couldn't get temporary file\n&quot;);
<br />
!     return;
<br />
!   }
<br />
!   GetConfigLine(Fvwm_fd,&amp;tline);
<br />
!   while (tline != (char *) 0) {
<br />
!       fputs(tline, ptr);
<br />
!       GetConfigLine(Fvwm_fd,&amp;tline);
<br />
!   }
<br />
!   rewind(ptr);
<br />
! 
<br />
!   
<br />
! #else /* FVWM95 */
<br />
&nbsp;&nbsp;&nbsp;&nbsp;ptr = fopen(file,&quot;r&quot;);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if (ptr == (FILE *)NULL) {
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConsoleMessage(&quot;Couldn't read configuration file (%s)...\n&quot;, file);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
+ #endif
<br />
&nbsp;&nbsp;&nbsp;&nbsp;tline = fgets(line,(sizeof line)-1,ptr);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;while (tline != (char *)0) {
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (isspace(*tline))tline++;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (strlen(tline)&gt;1 &amp;&amp; tline[0] != '#') {
<br />
***************
<br />
*** 678,683 ****
<br />
--- 728,734 ----
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tline = fgets(line,(sizeof line)-1,ptr);
<br />
&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
+   fclose(ptr);
<br />
&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;/*****************************************************************************
<br />
*
<br />
***************
<br />
*** 717,725 ****
<br />
&nbsp;&nbsp;/*****************************************************************************
<br />
*
<br />
&nbsp;&nbsp;&nbsp;&nbsp;Alarm - Handle a SIGALRM - used to implement timeout events
<br />
&nbsp;&nbsp;******************************************************************************
<br />
/
<br />
! void Alarm(int nonsense) {
<br />
&nbsp;&nbsp;
<br />
!   switch(AlarmSet) {
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;case SHOW_TIP:
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowTipWindow(1);
<br />
--- 768,786 ----
<br />
&nbsp;&nbsp;/*****************************************************************************
<br />
*
<br />
&nbsp;&nbsp;&nbsp;&nbsp;Alarm - Handle a SIGALRM - used to implement timeout events
<br />
&nbsp;&nbsp;******************************************************************************
<br />
/
<br />
! void SigAlarm(int nonsense) {
<br />
! 
<br />
!     /*
<br />
!      * send an alarm to the main loop
<br />
!      */
<br />
!   static char buffer[1] = { (char) SIGNAL_ALARM };
<br />
!   write(signal_pipes[0], buffer, sizeof buffer);
<br />
! 
<br />
!   signal (SIGALRM, SigAlarm);
<br />
! }
<br />
&nbsp;&nbsp;
<br />
! void Alarm(void) {
<br />
! switch(AlarmSet) {
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;case SHOW_TIP:
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowTipWindow(1);
<br />
***************
<br />
*** 731,737 ****
<br />
&nbsp;&nbsp;&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;AlarmSet = NOT_SET;
<br />
-   signal (SIGALRM, Alarm);
<br />
&nbsp;&nbsp;}
<br />
&nbsp;&nbsp;
<br />
&nbsp;&nbsp;/*****************************************************************************
<br />
*
<br />
--- 792,797 ----
<br />
*** fvwm-2.0.46/extras/FvwmTaskBar/FvwmTaskBar.h.orig	Mon Sep 23 20:00:31 1996
<br />
--- fvwm-2.0.46/extras/FvwmTaskBar/FvwmTaskBar.h	Tue Aug 26 13:56:29 1997
<br />
***************
<br />
*** 81,87 ****
<br />
&nbsp;&nbsp;void ProcessMessage(unsigned long type,unsigned long *body);
<br />
&nbsp;&nbsp;void SendFvwmPipe(char *message,unsigned long window);
<br />
&nbsp;&nbsp;void DeadPipe(int nonsense);
<br />
! void Alarm(int nonsense);
<br />
&nbsp;&nbsp;void SetAlarm(int event);
<br />
&nbsp;&nbsp;void ClearAlarm(void);
<br />
&nbsp;&nbsp;void CheckForTip(int x, int y);
<br />
--- 81,88 ----
<br />
&nbsp;&nbsp;void ProcessMessage(unsigned long type,unsigned long *body);
<br />
&nbsp;&nbsp;void SendFvwmPipe(char *message,unsigned long window);
<br />
&nbsp;&nbsp;void DeadPipe(int nonsense);
<br />
! void SigAlarm(int nonsense);
<br />
! void Alarm(void);
<br />
&nbsp;&nbsp;void SetAlarm(int event);
<br />
&nbsp;&nbsp;void ClearAlarm(void);
<br />
&nbsp;&nbsp;void CheckForTip(int x, int y);
<br />
<br />End of MIME message
<br />
<pre>
--
Visit the official FVWM web page at &lt;URL:<a href="http://www.hpc.uh.edu/fvwm/">http://www.hpc.uh.edu/fvwm/</a>&gt;.
To unsubscribe from the list, send &quot;unsubscribe fvwm&quot; in the body of a
message to majordomo_at_hpc.uh.edu.
To report problems, send mail to fvwm-owner_at_hpc.uh.edu.
</pre>
<span id="received"><dfn>Received on</dfn> Wed Aug 27 1997 - 16:14:41 BST</span>
</div>
<!-- body="end" -->
<div class="foot">
<map id="navbarfoot" name="navbarfoot" title="Related messages">
<ul class="links">
<li><dfn>This message</dfn>: [ <a href="#start20824">Message body</a> ]</li>
<!-- lnext="start" -->
<li><dfn>Next message</dfn>: <a href="20825.html" title="Next message in the list">Martin Cartwright: "Re: FVWM: pager balloons"</a></li>
<li><dfn>Previous message</dfn>: <a href="20823.html" title="Previous message in the list">Broc Stirton: "Re: FVWM: Another question about starting Aps"</a></li>
<li><dfn>In reply to</dfn>: <a href="20801.html" title="Message to which this message replies">Grant McDorman: "FVWM: fvwm 2.0.46: patches and bugs"</a></li>
<!-- lnextthread="start" -->
<li><dfn>Next in thread</dfn>: <a href="20827.html" title="Next message in this discussion thread">Bruce Stephens: "Re: FVWM: fvwm 2.0.46: patches and bugs: NEW PATCH"</a></li>
<li><a name="replies" id="replies"></a>
<dfn>Reply</dfn>: <a href="20827.html" title="Message sent in reply to this message">Bruce Stephens: "Re: FVWM: fvwm 2.0.46: patches and bugs: NEW PATCH"</a></li>
<!-- lreply="end" -->
</ul>
<ul class="links">
<li><a name="options3" id="options3"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg20824" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg20824" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg20824" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg20824" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</map>
</div>
<!-- trailer="footer" -->
<p><small><em>
This archive was generated by <a href="http://www.hypermail-project.org/">hypermail 2.3.0</a>
: Mon Aug 29 2016 - 19:38:00 BST
</em></small></p>
</body>
</html>
